# CHAPTER 2 TypeScript’s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> ❗ JS에서 `typeof null`은 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space

## Item 9: Prefer Type Declarations to Type Assertions

## Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)

## Item 11: Recognize the Limits of Excess Property Checking

## Item 12: Apply Types to Entire Function Expressions When Possible

## Item 13: Know the Differences Between type and interface

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

## Item 15: Use Index Signatures for Dynamic Data

## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

## Item 17: Use readonly to Avoid Errors Associated with Mutation

## Item 18: Use Mapped Types to Keep Values in Sync
