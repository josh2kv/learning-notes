# CHAPTER 2 TypeScript’s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> ❗ JS에서 `typeof null`은 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

### TypeScript terms and set terms

| **TypeScript term**   | **Set term**            |
|-----------------------|-------------------------|
| never                 | ∅ (empty set)           |
| Literal type          | Single element set      |
| Value assignable to T | Value ∈ T (member of)   |
| T1 assignable to T2   | T1 ⊆ T2 (subset of)     |
| T1 extends T2         | T1 ⊆ T2 (subset of)     |
| T1 | T2               | T1 ∪ T2 (union)         |
| T1 & T2               | T1 ∩ T2 (intersection)  |
| unknown               | Universal set           |

### assignable = members of(values-types) or subset of(types-types)

- 결국 type checker가 하는 일의 대부분은 하나의 집합이 다른 집합의 부분집합인지 테스트하는 일

- `number[]`는 `[]` 와 `list[1]`도 가능하므로 `tuple`의 부분집합이 아님

```ts
const list = [1, 2]; // Type is number[]
const tuple: [number, number] = list;
// ~~~~~ Type 'number[]' is missing the following
// properties from type '[number, number]': 0, 1
```

- TS가 tuple을 length를 넣어 모델링 함
  - `{0: number, 1: number, length: 2}`

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

- `Exclude<UnionType, ExcludedMembers>`

```ts
type T = Exclude<string|Date, string|number>; // Type is Date
type NonZeroNums = Exclude<number, 0>; // Type is still just number
```

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space

## Item 9: Prefer Type Declarations to Type Assertions

## Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)

## Item 11: Recognize the Limits of Excess Property Checking

## Item 12: Apply Types to Entire Function Expressions When Possible

## Item 13: Know the Differences Between type and interface

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

## Item 15: Use Index Signatures for Dynamic Data

## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

## Item 17: Use readonly to Avoid Errors Associated with Mutation

## Item 18: Use Mapped Types to Keep Values in Sync
