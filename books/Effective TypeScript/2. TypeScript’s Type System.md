# CHAPTER 2 TypeScriptâ€™s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> ğŸš¨ JS runtimeì—ì„œ `typeof null`ì€ 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

### TypeScript terms and set terms

| **TypeScript term**   | **Set term**            |
|-----------------------|-------------------------|
| never                 | âˆ… (empty set)           |
| Literal type          | Single element set      |
| Value assignable to T | Value âˆˆ T (member of)   |
| T1 assignable to T2   | T1 âŠ† T2 (subset of)     |
| T1 extends T2         | T1 âŠ† T2 (subset of)     |
| T1 | T2               | T1 âˆª T2 (union)         |
| T1 & T2               | T1 âˆ© T2 (intersection)  |
| unknown               | Universal set           |

### assignable = members of(values-types) or subset of(types-types)

- ê²°êµ­ type checkerê°€ í•˜ëŠ” ì¼ì˜ ëŒ€ë¶€ë¶„ì€ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë‹¤ë¥¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì¸ì§€ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì¼

- `number[]`ëŠ” `[]` ì™€ `list[1]`ë„ ê°€ëŠ¥í•˜ë¯€ë¡œ `tuple`ì˜ ë¶€ë¶„ì§‘í•©ì´ ì•„ë‹˜

```ts
const list = [1, 2]; // Type is number[]
const tuple: [number, number] = list;
// ~~~~~ Type 'number[]' is missing the following
// properties from type '[number, number]': 0, 1
```

- TSê°€ tupleì„ lengthë¥¼ ë„£ì–´ ëª¨ë¸ë§ í•¨
  - `{0: number, 1: number, length: 2}`

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple; 
// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

- `Exclude<UnionType, ExcludedMembers>`

```ts
type T = Exclude<string|Date, string|number>; // Type is Date
type NonZeroNums = Exclude<number, 0>; // Type is still just number
```

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space
>
> ğŸ“ symbols?
>
> : a symbol is a unique identifier that is used to represent some entity within the program, such as a variable, function, or class.

- `InstanceType<Type>`: constructor type(function, `typeof Class`)ì„ ë„£ì–´ instance type(object)ì„ ì–»ì„ ìˆ˜ ìˆìŒ

| Concept | Value Space | Type Space |
|---------|-------------|------------|
|`typeof`| returns a string containing the runtime type of the symbol | returns its TypeScript type|
| `this`  | JavaScript `this` keyword  | TypeScript type of `this` (aka "polymorphic this") |
| `&` and `\|` | Bitwise AND and OR | Intersection and union operators |
| `const` | Introduces a new variable | Changes the inferred type of a literal or literal expression |
| `extends` | Defines a subclass (`class A extends B`) or a subtype (`interface A extends B`) or a constraint on a generic type (`Generic<T extends number>`) | Defines a type constraint between types |
| `in` | Part of a loop (`for (key in object)`) | Mapped type|

- value spaceì™€ type spaceì˜ êµ¬ë¶„ì„ ì§ì ‘ í™•ì¸í•˜ë ¤ë©´ TypeScript Playgroundë¥¼ ì´ìš©í•˜ì—¬ í™•ì¸

## Item 9: Prefer Type Declarations to Type Assertions

> ğŸš¨ `const bob = <Person>{}`
>
> `const bob = {} as Person`ì˜ ì˜›ë‚ ë°©ì‹
> TypeScript + Reactì¸ .tsx íŒŒì¼ì—ì„  `<Person>`ì´ ì‹œì‘ íƒœê·¸ë¡œ í•´ì„ë˜ê¸° ë•Œë¬¸ì— ì˜ ì“°ì´ì§€ ì•ŠìŒ

### arrow functionì˜ return type ì •í•˜ê¸°

```ts
interface Person { name: string };

const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]

// âŒ
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]

// âœ…
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);
```

- type assertionì„ ì‚¬ìš©í•˜ë©´ type errorê°€ ìˆì–´ë„ ì¡ì•„ë‚´ì§€ ëª»í•¨

  ```ts
  const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
  // No error
  ```

### ì–¸ì œ type assertionì„ ì¨ì•¼ í•˜ë‚˜

- type checkerë³´ë‹¤ ê·¸ typeì— ëŒ€í•´ í™•ì‹¤íˆ ì•Œ ë•Œë§Œ ì‚¬ìš©(type checkerëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” contextì¸ ê²½ìš°)
  - TSëŠ” DOMì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ

  ```ts
  document.querySelector('#myButton').addEventListener('click', e => {
    e.currentTarget // Type is EventTarget
    const button = e.currentTarget as HTMLButtonElement;
    button // Type is HTMLButtonElement
  });
  ```

- `null`ì´ ì•„ë‹˜ì„ í™•ì‹ í•  ìˆ˜ ìˆì„ ë•Œë§Œ non-null assertion(`!`)ì„ ì‚¬ìš©í•˜ê³  ì•„ë‹ˆë©´ ì¡°ê±´ë¬¸ìœ¼ë¡œ `null`ì„ ì²´í¬í•˜ëŠ” í•  ê²ƒ

### type assertionì€ ì›ë˜ typeì˜ subset ì¤‘ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'
// may be a mistake because neither type sufficiently
// overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first
```

- ì–µì§€ë¡œ ë°”ê¾¸ê³  ì‹¶ë‹¤ë©´ `unknown`ì„ ì¤‘ê°„ì— ì„ì–´ì•¼ í•¨
  - ëª¨ë“  typeì€ `unknown`ì˜ subtypeì´ê¸° ë•Œë¬¸ì— ê°€ëŠ¥

```ts
const el = document.body as unknown as Person; // OK
```

## Item 10: Avoid Object Wrapper Types (`String`, `Number`, `Boolean`, `Symbol`, `BigInt`)

### Object Wrapperë¥¼ instantiateí•˜ê±°ë‚˜ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šê¸°

- built-in method í™•ì¸í•˜ê¸°

  - ì—¬ê¸°ì„œ `this`ëŠ” `String` object wrapper

 ```ts
 const originalCharAt = String.prototype.charAt;
 String.prototype.charAt = function(pos) {
   console.log(this, typeof this, pos);
   return originalCharAt.call(this, pos);
 };
 console.log('primitive'.charAt(3));
 // [String: 'primitive'] 'object' 3
 // m
 ```

- primitive stringì— propertyë¥¼ í• ë‹¹í•˜ë©´ í•´ë‹¹ propertyê°€ ì‚¬ë¼ì ¸ë²„ë¦¼

```ts
x = "hello"
x.language = 'English'
// 'English'
x.language
// undefined
```

- object wrapperëŠ” primitive valueì— í¸ì˜ë¥¼ ìœ„í•œ methodì™€ static methodë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ ì¡´ì¬í•¨
- object wrapperì— primitive valueë¥¼ í• ë‹¹í•  ìˆ˜ ìˆì§€ë§Œ ê·¸ ë°˜ëŒ€ëŠ” ì•ˆë¨

> ğŸ“ `BigInt`ì™€ `Symbol`ì€ `new` ì—†ì´ ì‚¬ìš©ê°€ëŠ¥  
> primitive valueë¥¼ ë§Œë“¤ê¸° ë•Œë¬¸ì—  
> ex) typeof BigInt(1234) // bigint
>
## Item 11: Recognize the Limits of Excess Property Checking

### Excess Property Checkingì´ ìˆ˜í–‰ë˜ëŠ” ì¡°ê±´

- object literalì„ variableì´ë‚˜ argumentì— ì§ì ‘ í• ë‹¹í•  ë•Œ
  - but, type assertionì„ ì‚¬ìš©í•˜ë©´ excess property checking ìƒëµ
- object literalì„ ì–´ë–¤ ì¤‘ê°„ variableì— ë„£ì€ ë’¤ì— ë„˜ê¸°ë©´ excess property checkingì€ ìˆ˜í–‰ë˜ì§€ ì•ŠìŒ
- regular assignability checkì™€ëŠ” ë³„ê°œì˜ í”„ë¡œì„¸ìŠ¤ë¡œ ì·¨ê¸‰í•˜ê¸°

> ğŸ“ Why do excess property checks be performed only when assigning object literals in TypeScript?
> Excess property checks are not performed when you assign an object that was created using a constructor function or an object that was obtained from another source, such as a database or an API response. This is because TypeScript assumes that the properties of these objects have already been checked by the constructor or the data source, and therefore does not perform any additional checks.
> By performing excess property checks only when assigning object literals, TypeScript helps catch a common class of errors that are caused by typos or programming mistakes, while also avoiding unnecessary checks for objects that are likely to have been previously validated.

## Item 12: Apply Types to Entire Function Expressions When Possible

- function *statement* ëŒ€ì‹  function *expression*ì„ ì‚¬ìš©í•˜ë©´ type declarationì„ function ì „ì²´ì— ì ìš©í•  ìˆ˜ ìˆìŒ

### ë°˜ë³µì„ ì¤„ì´ê¸° ìœ„í•´ ì‚¬ìš©

- libraryì—ì„œ ì •ì˜ëœ typeì„ ê°€ì ¸ë‹¤ ì“¸ ë•Œ parameterì™€ return typeì„ ê°ê° ê°€ì ¸ë‹¤ ì“°ì§€ë§ê³  functionì„ í†µì§¸ë¡œ ê°€ì ¸ë‹¤ ì“¸ ê²ƒ
  - ReactJSëŠ” parameterë¥¼ ìœ„í•œ `MouseEvent`ì™€ functionì„ ìœ„í•œ `MouseEventHandler`ë¥¼ ì œê³µ -> `MouseEventHandler`ë¥¼ ì“°ì
  - libraryë¥¼ ë§Œë“ ë‹¤ë©´ common callbackì„ ìœ„í•œ type declarationì„ ì œê³µí•˜ì

### ë‹¤ë¥¸ ì–´ë–¤ functionì˜ signatureì™€ ì¼ì¹˜ì‹œí‚¤ê¸° ìœ„í•´ ì‚¬ìš©

- ë‹¤ë¥¸ functionì˜ signatureì™€ matching í•  ë•ŒëŠ” `typeof fn`ì„ ì‚¬ìš©í•˜ì

> ğŸ“ signatures?
> : a unique identifier for the function or method, based on its name and the types of its arguments and return values. A function's signature includes the function name and the number and types of its parameters, but not the implementation or the code inside the function.

> ğŸš¨ `fetch()`ì˜ error responseëŠ” rejected Promiseê°€ ì•„ë‹˜
> requestê°€ ì‹¤íŒ¨í–ˆì„ ë•Œ responseì˜ bodyëŠ” JSONì´ ì•„ë‹Œ "404 Not Found"ê°™ì€ textì„
> ë”°ë¼ì„œ ê·¸ëƒ¥ `response.json()`í•˜ë©´ 404ê°™ì€ ì‘ë‹µì½”ë“œì™€ ê·¸ ë‚´ìš©ì„ ë°›ëŠ” ê²ƒì´ ì•„ë‹Œ "invalid JSON"ì´ë¼ëŠ” ì—ëŸ¬ê°€ ë‚˜íƒ€ë‚¨

```ts
// âŒ
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
return quote;
}

declare function fetch(
input: RequestInfo, init?: RequestInit
): Promise<Response>;

// ğŸ¤”
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
const response = await fetch(input, init);
if (!response.ok) {
  // Converted to a rejected Promise in an async function
  throw new Error('Request failed: ' + response.status);
}
  return response;
}

// âœ…
const checkedFetch: typeof fetch = async (input, init) => {
const response = await fetch(input, init);
  if (!response.ok) {
  throw new Error('Request failed: ' + response.status);
}
  return response;
}
```

- return typeë„ ë³´ì¥í•´ì¤Œ

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  // ~~~~~~~~~~~~ Type 'Promise<Response | HTTPError>'
  // is not assignable to type 'Promise<Response>'
  // Type 'Response | HTTPError' is not assignable
  // to type 'Response'
  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error('Request failed: ' + response.status);
  }
    return response;
}
```

## Item 13: Know the Differences Between `type` and `interface`

> ğŸš¨ `I` prefixë¥¼ ì‚¬ìš©í•˜ì§€ ë§ì
> ìš”ì¦˜ì—” ë‚˜ìœ ìŠ¤íƒ€ì¼ë¡œ ì—¬ê²¨ì§. ë¶ˆí•„ìš”í•˜ê³  standard libraryë“¤ì´ ì¼ê´€ë˜ê²Œ ë”°ë¥´ì§€ ì•ŠìŒ

### ë‘˜ë‹¤ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- excess property checking
- using index signatures
- defining function type
  - type aliasê°€ ë” ìì—°ìŠ¤ëŸ¬ì›€

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
```

- using generic
- extending types
  - `interface`ì™€ `type`ëŠ” ì„œë¡œë¥¼ extend ê°€ëŠ¥

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number; };
```

- classëŠ” ë‘˜ë‹¤ `implements` ê°€ëŠ¥

### `type`ë§Œ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- union types
  - union typesì™€ `interface` ì¡°í•©í•˜ì—¬ variable map ë§Œë“¤ê¸°

  ```ts
  type Input = {
    x: number;
    y: number;
  };

  type Output = {
    result: number;
  };

  interface VariableMap {
    [name: string]: Input | Output;
  }

  type NamedVariable = (Input | Output) & { name: string };

  const input1: Input = { x: 1, y: 2 };
  const output1: Output = { result: 3 };

  const variableMap: VariableMap = {
    'input1': input1,
    'output1': output1,
  };

  const namedVariable: NamedVariable = { name: 'input1', ...input1 };
  console.log(namedVariable) // { "name": "input1", "x": 1, "y": 2 } 
  ```

- mapped or conditional types

> ğŸ“ mapped types
> : A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.
>
>   ```ts
>   type OptionsFlags<Type> = {
>     [Property in keyof Type]: boolean;
>   };
>   ```

> ğŸ“ conditional types
> : A type construct that allows you to define a type based on a condition. They are used to create flexible and reusable type definitions that can handle different scenarios based on the properties of the input types.
>
>   ```ts
>   SomeType extends OtherType ? TrueType : FalseType
>   ```
>
- tuple
  - `interface`ë¡œë„ êµ¬í˜„ ê°€ëŠ¥í•˜ì§€ë§Œ ì˜ ì´ìƒí•˜ê³  array methodë“¤ë¥¼ ì‚¬ìš©ëª»í•˜ê²Œ ë˜ë¯€ë¡œ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒ

  ```ts
  // ğŸ¤”
  interface Tuple {
    0: number;
    1: number;
    length: 2;
  }
  const t: Tuple = [10, 20];
  ```

### `interface`ë§Œ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- declaration merging(augment)
  - ì£¼ë¡œ declaration fileì—ì„œ ì‚¬ìš©ë¨
  - type declarationì„ ë§Œë“  ì‚¬ëŒê³¼ ê·¸ ê²ƒì„ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì´ ì›í•˜ëŠ” typeì— gapì´ ìˆì„ ë•Œ í•„ìš”í•œ ê²ƒì„ ì¶”ê°€í•˜ì—¬ í•©ì¹  ìˆ˜ ìˆìŒ
  - TSëŠ” JS's standard libraryì˜ versionì— ë”°ë¼ ë‹¤ë¥¸ typeë“¤ì„ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ì´ë¥¼ ì‚¬ìš©í•¨
    - ì˜ˆë¥¼ ë“¤ì–´ defaultë¡œ `lib.es5.d.ts`ë¥¼ ì‚¬ìš©í•˜ê³  ê·¸ëŸ¬ë©´ ES6ì´ì „ì˜ `Array` methodë“¤ë§Œ í¬í•¨ëœ interfaceê°€ ë“¤ì–´ìˆìŒ
    - `tsconfig.json`ì˜ `lib` entryì— 'ES2015`ë¥¼ ì¶”ê°€í•œë‹¤ë©´`lib.es2015.d.ts`ë¥¼ ê°™ì´ í¬í•¨ì‹œì¼œ`Array` interfaceê°€ mergeë˜ì–´ `find()`ê°™ì€ ES6ì´í›„ methodë“¤ë„ ì“¸ ìˆ˜ ìˆê²Œ ë¨
  - ë‹¤ë¥¸ ëˆ„êµ°ê°€ typeì„ augmentí•˜ëŠ” ê±¸ ì›í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `interface`ëŒ€ì‹  `type`ì„ ì‚¬ìš©

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}
const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 500_000
}; // OK
```

### ë‘˜ ì¤‘ ì–´ë–¤ ê±¸ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜?

- ë³µì¡í•œ typeì´ë©´?
  - `type` ì‚¬ìš©
- ë¹„êµì  ê°„ë‹¨í•œ typeì´ì—¬ì„œ ë‘˜ë‹¤ êµ¬í˜„ ê°€ëŠ¥í•˜ë©´?
  - consistencyì™€ augmentationì„ ê³ ë ¤í•˜ì—¬ ê²°ì •
  - ê¸°ì¡´ codebaseì—ì„œ ì •í•´ì§„ ìŠ¤íƒ€ì¼ëŒ€ë¡œ ë”°ë¼ê°€ì
    - ì •í•´ì§„ ìŠ¤íƒ€ì¼ì´ ì—†ë‹¤ë©´?
      - for external(API ë“±): `interface`
      - for internal: `type`

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

### typeì— ì´ë¦„ì„ ë¶™ì´ì

- logic codeì—ì„œ valueë¥¼ variableì— ë‹´ì•„ ì¬ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê°™ìŒ

- base type(`Person`)ì´ ì¬ì‚¬ìš©ë˜ëŠ” ê²½ìš°(spread bottom->top): `interface` ì‚¬ìš©

```ts
interface Person {
  firstName: string;
  lastName: string;
}
interface PersonWithBirthDate extends Person {
  birth: Date;
}
```

- ì–´ë–¤ typeì´ ë‹¤ë¥¸ typeì— ì™„ì „íˆ ì¢…ì†ì ì¸ ê²½ìš°(spread top->bottom): mapped typeì´ë‚˜ `Pick` ì‚¬ìš©

```ts
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

// ğŸ‘ bad
interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
}

// ğŸ‘ good
// ğŸš¨ ì˜ëª»ëœ(`State`ì— ì—†ëŠ”) propertyë¥¼ ì¶”ê°€í•´ë„ type errorê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
type TopNavState = {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
  // dd: string
};

// ğŸ¤© better(mapped type)
// ì˜ëª»ëœ(`State`ì— ì—†ëŠ”) propertyë¥¼ ì¶”ê°€í•˜ë©´ type errorê°€ ë°œìƒì‹œì¼œì¤Œ ex) | 'dd']
type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
};

// ğŸ† best(`Pick`)
// ì˜ëª»ëœ(`State`ì— ì—†ëŠ”) propertyë¥¼ ì¶”ê°€í•˜ë©´ type errorê°€ ë°œìƒì‹œì¼œì¤Œ ex) | 'dd'>
type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;
// {userId: string; pageTitle: string; recentFiles: string[];} 
```

> ğŸ“ `Pick<Type, Keys>` = mapped type
> : Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type

### generic typeì„ ì‚¬ìš©í•˜ì

- logic codeì—ì„œ ì¬ì‚¬ìš©í•˜ê¸° ìœ„í•´ functionë¡œ ë§Œë“¤ì–´ í˜¸ì¶œí•˜ëŠ” ê²ƒê³¼ ê°™ìŒ
- tagged union: union typeì— indexing ì‚¬ìš©

```ts
interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}
type Action = SaveAction | LoadAction;

// ğŸ‘ bad
type ActionType = 'save' | 'load';

// ğŸ‘ good
type ActionType = Action['type']; // "save" | "load"

// cf) `Pick`
type ActionRec = Pick<Action, 'type'>; // {type: "save" | "load"}
```

- classì—ì„œ ì´ˆê¸°í™” í›„ ì—…ë°ì´íŠ¸ í•˜ëŠ” ê²½ìš°: `Partial` ì‚¬ìš©
  - ë³´í†µ ì—…ë°ì´íŠ¸ì‹œ optionì€ ì´ˆê¸°í™”ì‹œ optionì„ optionally ëŒ€ë¶€ë¶„ í¬í•¨í•˜ëŠ” í˜•íƒœ

```ts
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
// ğŸ‘ bad
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}
class UIWidget {
  constructor(init: Options) { /* ... */ }
  update(options: OptionsUpdate) { /* ... */ }
}

// ğŸ‘ good
type OptionsUpdate = {[k in keyof Options]?: Options[k]};

// ğŸ† best
class UIWidget {
  constructor(init: Options) { /* ... */ }
  update(options: Partial<Options>) { /* ... */ }
}
```

> ğŸ“ `Partial<Type>` = `?`ê³¼ `keyof`ë¡œ ì¡°í•©í•œ mapped type
> : Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.
>

- valueì—ì„œ typeì„ ì¶”ì¶œí•˜ëŠ” ê²½ìš°: `typeof`ì‚¬ìš©
  - ğŸš¨ ë³´í†µì€ typeì„ ë¨¼ì € ì •ì˜í•˜ê³  valueì— ì ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìœ¼ë‹ˆ ì£¼ì˜í•˜ì—¬ ì‚¬ìš©

```ts
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};
// ğŸ‘ bad
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

// ğŸ‘ good
type Options = typeof INIT_OPTIONS;
```

- functionì˜ return valueì—ì„œ typeì„ ì¶”ì¶œí•˜ëŠ” ê²½ìš°: `ReturnType`ì‚¬ìš©
  - functionì´ ì•„ë‹Œ functionì˜ type(`typeof` function)ì„ argumentë¡œ ë„£ì–´ì•¼ í•¨

```ts
function getUserInfo(userId: string) {
  // ...
  return {
  userId,
  name,
  age,
  height,
  weight,
  favoriteColor,
  };

type UserInfo = ReturnType<typeof getUserInfo>;
```

- generic typeì˜ type parameterë¥¼ ì œí•œí•˜ëŠ” ê²½ìš°: `extends` ì‚¬ìš©

```ts
interface Name {
  first: string;
  last: string;
}
type DancingDuo<T extends Name> = [T, T];
const couple1: DancingDuo<Name> = [
  {first: 'Fred', last: 'Astaire'},
  {first: 'Ginger', last: 'Rogers'}
]; // OK
const couple2: DancingDuo<{first: string}> = [
  // ~~~~~~~~~~~~~~~
  // Property 'last' is missing in type
  // '{ first: string; }' but required in type 'Name'
  {first: 'Sonny'},
  {first: 'Cher'}
];
```

> ğŸ’¡ generic typeì— type parameterë¥¼ ì§ì ‘ ì œê³µí•˜ì§€ ì•Šê³  ì‚¬ìš©í•˜ê¸°
> TSëŠ” ê¸°ë³¸ì ìœ¼ë¡œ generic typeì„ ì‚¬ìš©í•  ë•Œ ë¬´ì¡°ê±´ type parameterë¥¼ ìš”êµ¬í•œë‹¤. generic typeì— type parameterë¥¼ ì œê³µí•˜ì§€ ì•Šê³  TSê°€ type parameterë¥¼ inferenceí•˜ë„ë¡ í•˜ê³  ì‹¶ë‹¤ë©´ typed identity functionì„ ì‚¬ìš©í•˜ì
>
> ```ts
>  const dancingDuo = <T extends Name>(x: DancingDuo<T>) => x;
>  const couple1 = dancingDuo([
>    {first: 'Fred', last: 'Astaire'},
>    {first: 'Ginger', last: 'Rogers'}
>  ]);
>  const couple2 = dancingDuo([
>    {first: 'Bono'},
>    // ~~~~~~~~~~~~~~
>    {first: 'Prince'}
>    // ~~~~~~~~~~~~~~~~
>    // Property 'last' is missing in type
>    // '{ first: string; }' but required in type 'Name'
>  ]);
>```

```ts
// âŒ
// keyì˜ type(`K`)ë²”ìœ„ê°€ ë„ˆë¬´ ë„“ìŒ. indexë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆëŠ” string, number and symbol ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•¨
type Pick<T, K> = {
  [k in K]: T[k]
  // ~ Type 'K' is not assignable to type 'string | number | symbol'
};

// âœ…
type Pick<T, K extends keyof T> = {
[k in K]: T[k]
}; // OK
```

## Item 15: Use Index Signatures for Dynamic Data

- *A name for the keys*: ë‹¨ìˆœíˆ ê¸°ë¡ìš©. ì‚¬ìš©x
- *A type for the key*: `string`, `number` or `symbol`ì˜ ì¡°í•©ì´ì—¬ì•¼ í•¨

### index signaturesì˜ ë¬¸ì œì 

- keyì— ì œì•½ì´ ì—†ìŒ
- value typeì„ í•˜ë‚˜ë¡œ í†µì¼í•´ì•¼ í•¨
- TSì˜ language service ì‚¬ìš© ë¶ˆê°€

```ts
// ğŸ‘ bad
type Rocket = {[property: string]: string};
const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  NAME: 'dd'  // OK
  // thrust: '4,940 kN',
  thrust: 4,940,  // Error
};
const emptyObject: Rocket = {}  // OK

// ğŸ‘ good
interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}
const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15_200
};

```

### index signaturesë¥¼ ì¨ì•¼í•˜ëŠ” ê²½ìš°

- for dynamic data: ë¯¸ë¦¬ ì–´ë–¤ ë°ì´í„°ê°€ ë“¤ì–´ì˜¬ ì§€ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš°
- ex. CSVíŒŒì¼ì„ ë°›ì•„ parsingí•˜ëŠ” ê²½ìš°

  ```ts
  function parseCSV(input: string): {[columnName: string]: string}[] {
    const lines = input.split('\n');
    const [header, ...rows] = lines;
    return rows.map(rowStr => {
      const row: {[columnName: string]: string} = {};
        rowStr.split(',').forEach((cell, i) => {
        row[header[i]] = cell;
      });
      return row;
    });
  }
  ```

  - ë¯¸ë¦¬ columnì„ ì•Œê³  ìˆë‹¤ë©´ type assertionì„ ì„ì–´ row typeì„ ì„ ì–¸

  ```ts
  interface ProductRow {
    productId: string;
    name: string;
    price: string;
  }
  declare let csvData: string;
  const products = parseCSV(csvData) as unknown as ProductRow[];
  ```

  - column valueê°€ ì œëŒ€ë¡œ ë“¤ì–´ì˜¤ì§€ ì•Šì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ value typeì— `undefined` ì¶”ê°€
    - í•˜ì§€ë§Œ íŠ¹ì • ì‘ì—…ì˜ ê²½ìš° ë˜ë‹¤ë¥¸ ì—ëŸ¬ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìƒí™©ì— ë§ê²Œ ì‚¬ìš©

  ```ts
  function safeParseCSV(input: string): {[columnName: string]: string | undefined}[] {
    return parseCSV(input);
  }

  const rows = parseCSV(csvData);
  const prices: {[produt: string]: number} = {};
  for (const row of rows) {
    prices[row.productId] = Number(row.price);
  }
  const safeRows = safeParseCSV(csvData);
  for (const row of safeRows) {
    prices[row.productId] = Number(row.price);
    // ~~~~~~~~~~~~~ Type 'undefined' cannot be used as an index type
  }
  ```

  - ë“¤ì–´ì˜¬ ìˆ˜ ìˆëŠ” column fieldê°€ ì œí•œë˜ì–´ ìˆë‹¤ë©´ index signaturesë¥¼ ì‚¬ìš©x

  ```ts
  // ğŸ‘ Too broad
  interface Row1 { [column: string]: number }

  // ğŸ‘ Better
  interface Row2 { a: number; b?: number; c?: number; d?: number }

  // ğŸ† The most precise, but it may be less convenient
  type Row3 =
    | { a: number; }  // ë§¨ ì•ì— `|` ìˆì–´ë„ OK
    | { a: number; b: number; }
    | { a: number; b: number; c: number; }
    | { a: number; b: number; c: number; d: number };
  ```

- index signatures ì‚¬ìš©ì‹œ `string`ì´ ë„ˆë¬´ ê´‘ë²”ìœ„í•œ ê²ƒì´ ë¬¸ì œë¼ë©´?
  - `Record` ì‚¬ìš©

  ```ts
  type Vec3D = Record<'x' | 'y' | 'z', number>;
  // Type Vec3D = {
  // x: number;
  // y: number;
  // z: number;
  // }
  ```

  - mapped or conditional type ì‚¬ìš©

  ```ts
  // ìœ„ `Record`ì™€ ê°™ìŒ
  type Vec3D = {[k in 'x' | 'y' | 'z']: number};

  // ğŸ’¡ conditional type: keyì— ë”°ë¼ ë‹¤ë¥¸ value type ì„¤ì • ê°€ëŠ¥
  type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};
  // Type ABC = {
  // a: number;
  // b: string;
  // c: number;
  // }
  ```

> ğŸ“ `Record<Keys, Type>`
> : Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.
>
## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

### arrayëŠ” objectì´ë¯€ë¡œ arrayì˜ index(key)ë“¤ì€ numberê°€ ì•„ë‹Œ string

- JSì—ì„œ stringì´ ì•„ë‹Œ objectì˜ keyë“¤ì€ implicitly `toString()`ì„ í†µí•´ stringìœ¼ë¡œ ë³€í™˜ë¨
  - objectê°€ keyë¡œ ë“¤ì–´ì˜¤ë©´ stringìœ¼ë¡œ ë°”ê¿”ì„œ ì €ì¥ë¨

  ```bash
  > x = {}
  {}
  > x[[1, 2, 3]] = 2
  2
  > x
  { '1,2,3': 1 }
  ```

  - numberëŠ” keyê°€ ë  ìˆ˜ ì—†ìŒ

  ```bash
  > { 1: 2, 3: 4}
  { '1': 2, '3': 4 }
  ```

  - arrayëŠ” objectì´ë¯€ë¡œ ê° elementì˜ indexë“¤ì€ ì‹¤ì œë¡œ numberê°€ ì•„ë‹Œ string

  ```bash
  > typeof []
  'object'
  > x = [1, 2, 3]
  [ 1, 2, 3 ]
  // ğŸ’¡ numberë¥¼ stringìœ¼ë¡œ ë³€í™˜í•˜ì—¬ elementë¥¼ accessí•¨
  > x[0]
  1
  > x['1']
  2
  > Object.keys(x)
  [ '0', '1', '2' ]
  68
  ```

- TSëŠ” ë‚´ë¶€ì ìœ¼ë¡œ numeric index signatureë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ í¸ì˜ë¥¼ ìœ„í•œ ê²ƒì¼ë¿ ì‹¤ì œ keyëŠ” string
  - ê·¸ë˜ì„œ keyì˜ typeì´ numberì™€ stringìœ¼ë¡œ ì„ì—¬ì„œ ë“±ì¥í•˜ëŠ” ê¸°ì´í•œ í˜„ìƒì„ ë§Œë“¤ì–´ëƒ„
  - ë”°ë¼ì„œ ì´ëŸ° í˜¼ë™ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆëŠ” numeric index signatureëŠ” ì›¬ë§Œí•˜ë©´ ì‚¬ìš©í•˜ì§€ ë§ì

```ts
// `lib.es5.d.ts`
interface Array<T> {
  // ...
  [n: number]: T;
}
```

```ts
const xs = [1, 2, 3];
const x0 = xs[0]; // OK
const x1 = xs['1'];
// ~~~ Element implicitly has an 'any' type
// because index expression is not of type 'number'
function get<T>(array: T[], k: string): T {
  return array[k];
  // ~ Element implicitly has an 'any' type
  // because index expression is not of type 'number'
}
const keys = Object.keys(xs); // Type is string[]
for (const key in xs) {
  key; // Type is string
  const x = xs[key]; // Type is number
}
```

> ğŸ’¡ loops for array
> ì†ë„: for-in << `Array.forEach()`< for-of < `Array.reduce()` < `while` << `for(;;)`
> <https://www.measurethat.net/Benchmarks/Show/10352/0/foreach-vs-for-len-vs-for-in-vs-for-of-vs-babel-for-of>

- arrayì— ë¶™ì€ prototype methodë“¤ì´ í•„ìš”ì—†ë‹¤ë©´ `ArrayLike`ë¥¼ ì‚¬ìš©

```ts
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if (i < xs.length) {
    return xs[i];
  }
  throw new Error(`Attempt to access ${i} which is past end of array.`)
}

```

> ğŸ“ `ArrayLike<T>`
> : a built-in type that describes an object that has a length property and indexed elements of a specific type.
> It is intended to represent objects that have some of the characteristics of arrays but may not be actual arrays, such as DOM NodeList or HTMLCollection objects.
>
>```ts
>type ArrayLike<T> = {
>  readonly length: number;
>  readonly [n: number]: T; // keyê°€ ì‹¤ì œë¡œëŠ” string
>};
>
>const tupleLike: ArrayLike<string> = {
>  '0': 'A',
>  '1': 'B',
>  length: 2,
>}; // OK
>console.log(tupleLike[1]) // "B"
>```

## Item 17: Use readonly to Avoid Errors Associated with Mutation

### mutateí•˜ì§€ ì•ŠëŠ” functionì˜ parameterì—ëŠ” í•­ìƒ  `readonly`ë¥¼ ë¶™ì´ì

```ts
function arraySum(arr: readonly number[]) {
  let sum = 0, num;
  while ((num = arr.pop()) !== undefined) {
    // ~~~ 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
    return sum;
}
```

- `number []` is a subtype of `readonly number[]`
  - = `number []` is assignable `readonly number[]`

```ts
const a: number[] = [1, 2, 3];
const b: readonly number[] = a;
const c: number[] = b;
// ~ Type 'readonly number[]' is 'readonly' and cannot be
// assigned to the mutable type 'number[]'
```

### `readonly`ëŠ” immutableí•´ì•¼ í•˜ëŠ” (local) variableì„ mutable variableì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ì‹¤ìˆ˜ë¥¼ ì¡ì•„ë‚¼ ìˆ˜ ìˆìŒ

```ts
const sample = [
  "Frankenstein; or, The Modern Prometheus",
  "by Mary Shelley",
  "",
  "You will rejoice to hear that no disaster has accompanied the commencement",
  "of an enterprise which you have regarded with such evil forebodings. I arrived",
  "here yesterday, and my first task is to assure my dear sister of my welfare and",
  "increasing confidence in the success of my undertaking.",
  "",
  "I am already far north of London, and as I walk in the streets of Petersburgh,",
  "I feel a cold northern breeze play upon my cheeks, which braces my nerves and",
  "fills me with delight.",
];

function parseTaggedText(lines: string[]): string[][] {
  const paragraphs: string[][] = [];
  const currPara: string[] = [];

  const addParagraph = () => {
    if (currPara.length) {
      //  âŒ ìƒˆë¡œìš´ paragraphë¥¼ ì‹œì‘í•  ë•Œë§ˆë‹¤ ê¸°ì¡´ì— ë“¤ì–´ê°„ paragraphë“¤ì„ ì „ë¶€ ë¹ˆ arrayë¡œ ë§Œë“¤ì–´ë²„ë¦¼
      paragraphs.push(currPara);
      currPara.length = 0; // Clear the lines
    }
  };

  for (const line of lines) {
    if (!line) {
      addParagraph();
    } else {
      currPara.push(line);
    }
  }

  addParagraph();
  return paragraphs;
}

console.log(parseTaggedText(sample))  // [[], [], []]

// âœ…  `currPara`ëŠ” immutableí•´ì•¼í•¨
function parseTaggedText(lines: string[]): string[][] {
  const currPara: readonly string[] = [];
  const paragraphs: string[][] = [];
  const addParagraph = () => {
    if (currPara.length) {
      paragraphs.push(
        currPara
        // ~~~~~~~~ Type 'readonly string[]' is 'readonly' and
        // cannot be assigned to the mutable type 'string[]'
      );
      currPara.length = 0; // Clear lines
      // ~~~~~~ Cannot assign to 'length' because it is a read-only
      // property
    }
  };
  for (const line of lines) {
    if (!line) {
      addParagraph();
    } else {
      currPara.push(line);
      // ~~~~ Property 'push' does not exist on type 'readonly string[]'
    }
  }
  addParagraph();
  return paragraphs;
}

// ìœ„ type ì—ëŸ¬ í•´ê²°ë²•
// ğŸ‘
paragraphs.push([...currPara]);
// ğŸ¤”
const paragraphs: (readonly string[])[] = [];
// ğŸ¤”
paragraphs.push(currPara as string[]);
```

### `readonly`ëŠ” shallow ì²´í¬ì„

```ts
const dates: readonly Date[] = [new Date()];
dates.push(new Date());
// ~~~~ Property 'push' does not exist on type 'readonly Date[]'
dates[0].setFullYear(2037); // OK
```

- `ReadOnly` genericë„ ë§ˆì°¬ê°€ì§€

```ts
interface Outer {
  inner: {
  x: number;
}
}
const o: Readonly<Outer> = { inner: { x: 0 }};
o.inner = { x: 1 };
// ~~~~ Cannot assign to 'inner' because it is a read-only property
o.inner.x = 1; // OK
```

> ğŸ“ `Readonly<Type>`
> : Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.
>

- TSì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ deep readonly typeì„ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì“°ì
  - [ts-essentials](https://www.npmjs.com/package/ts-essentials)ì˜ `DeepReadonly`

### index signaturesë¥¼ immutableí•˜ê²Œ ì‚¬ìš©í•˜ë ¤ë©´ `readonly` ì‚¬ìš©í•˜ì

```ts
let obj: {readonly [k: string]: number} = {};
// Or Readonly<{[k: string]: number}
obj.hi = 45;
// ~~ Index signature in type ... only permits reading
obj = {...obj, hi: 12}; // OK
obj = {...obj, bye: 34}; // OK
```

## Item 18: Use Mapped Types to Keep Values in Sync
