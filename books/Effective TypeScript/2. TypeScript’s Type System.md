# CHAPTER 2 TypeScriptâ€™s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> ğŸš¨ JSì—ì„œ `typeof null`ì€ 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

### TypeScript terms and set terms

| **TypeScript term**   | **Set term**            |
|-----------------------|-------------------------|
| never                 | âˆ… (empty set)           |
| Literal type          | Single element set      |
| Value assignable to T | Value âˆˆ T (member of)   |
| T1 assignable to T2   | T1 âŠ† T2 (subset of)     |
| T1 extends T2         | T1 âŠ† T2 (subset of)     |
| T1 | T2               | T1 âˆª T2 (union)         |
| T1 & T2               | T1 âˆ© T2 (intersection)  |
| unknown               | Universal set           |

### assignable = members of(values-types) or subset of(types-types)

- ê²°êµ­ type checkerê°€ í•˜ëŠ” ì¼ì˜ ëŒ€ë¶€ë¶„ì€ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë‹¤ë¥¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì¸ì§€ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì¼

- `number[]`ëŠ” `[]` ì™€ `list[1]`ë„ ê°€ëŠ¥í•˜ë¯€ë¡œ `tuple`ì˜ ë¶€ë¶„ì§‘í•©ì´ ì•„ë‹˜

```ts
const list = [1, 2]; // Type is number[]
const tuple: [number, number] = list;
// ~~~~~ Type 'number[]' is missing the following
// properties from type '[number, number]': 0, 1
```

- TSê°€ tupleì„ lengthë¥¼ ë„£ì–´ ëª¨ë¸ë§ í•¨
  - `{0: number, 1: number, length: 2}`

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple; 
// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

- `Exclude<UnionType, ExcludedMembers>`

```ts
type T = Exclude<string|Date, string|number>; // Type is Date
type NonZeroNums = Exclude<number, 0>; // Type is still just number
```

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space
>
> ğŸ“– symbols
>
> : a symbol is a unique identifier that is used to represent some entity within the program, such as a variable, function, or class.

- `InstanceType<Type>`: constructor type(function, `typeof Class`)ì„ ë„£ì–´ instance type(object)ì„ ì–»ì„ ìˆ˜ ìˆìŒ

| Concept | Value Space | Type Space |
|---------|-------------|------------|
|`typeof`| returns a string containing the runtime type of the symbol | returns its TypeScript type|
| `this`  | JavaScript `this` keyword  | TypeScript type of `this` (aka "polymorphic this") |
| `&` and `\|` | Bitwise AND and OR | Intersection and union operators |
| `const` | Introduces a new variable | Changes the inferred type of a literal or literal expression |
| `extends` | Defines a subclass (`class A extends B`) or a subtype (`interface A extends B`) or a constraint on a generic type (`Generic<T extends number>`) | Defines a type constraint between types |
| `in` | Part of a loop (`for (key in object)`) | Mapped type|

- value spaceì™€ type spaceì˜ êµ¬ë¶„ì„ ì§ì ‘ í™•ì¸í•˜ë ¤ë©´ TypeScript Playgroundë¥¼ ì´ìš©í•˜ì—¬ í™•ì¸

## Item 9: Prefer Type Declarations to Type Assertions

> ğŸš¨ `const bob = <Person>{}`
>
> `const bob = {} as Person`ì˜ ì˜›ë‚ ë°©ì‹
> TypeScript + Reactì¸ .tsx íŒŒì¼ì—ì„  `<Person>`ì´ ì‹œì‘ íƒœê·¸ë¡œ í•´ì„ë˜ê¸° ë•Œë¬¸ì— ì˜ ì“°ì´ì§€ ì•ŠìŒ

### arrow functionì˜ return type ì •í•˜ê¸°

```ts
interface Person { name: string };

const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]

// âŒ
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]

// âœ…
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);
```

- type assertionì„ ì‚¬ìš©í•˜ë©´ type errorê°€ ìˆì–´ë„ ì¡ì•„ë‚´ì§€ ëª»í•¨

  ```ts
  const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
  // No error
  ```

### ì–¸ì œ type assertionì„ ì¨ì•¼ í•˜ë‚˜

- type checkerë³´ë‹¤ ê·¸ typeì— ëŒ€í•´ í™•ì‹¤íˆ ì•Œ ë•Œë§Œ ì‚¬ìš©(type checkerëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” contextì¸ ê²½ìš°)
  - TSëŠ” DOMì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ

  ```ts
  document.querySelector('#myButton').addEventListener('click', e => {
    e.currentTarget // Type is EventTarget
    const button = e.currentTarget as HTMLButtonElement;
    button // Type is HTMLButtonElement
  });
  ```

- `null`ì´ ì•„ë‹˜ì„ í™•ì‹ í•  ìˆ˜ ìˆì„ ë•Œë§Œ non-null assertion(`!`)ì„ ì‚¬ìš©í•˜ê³  ì•„ë‹ˆë©´ ì¡°ê±´ë¬¸ìœ¼ë¡œ `null`ì„ ì²´í¬í•˜ëŠ” í•  ê²ƒ

### type assertionì€ ì›ë˜ typeì˜ subset ì¤‘ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'
// may be a mistake because neither type sufficiently
// overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first
```

- ì–µì§€ë¡œ ë°”ê¾¸ê³  ì‹¶ë‹¤ë©´ `unknown`ì„ ì¤‘ê°„ì— ì„ì–´ì•¼ í•¨
  - ëª¨ë“  typeì€ `unknown`ì˜ subtypeì´ê¸° ë•Œë¬¸ì— ê°€ëŠ¥

```ts
const el = document.body as unknown as Person; // OK
```

## Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)

## Item 11: Recognize the Limits of Excess Property Checking

## Item 12: Apply Types to Entire Function Expressions When Possible

## Item 13: Know the Differences Between type and interface

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

## Item 15: Use Index Signatures for Dynamic Data

## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

## Item 17: Use readonly to Avoid Errors Associated with Mutation

## Item 18: Use Mapped Types to Keep Values in Sync
