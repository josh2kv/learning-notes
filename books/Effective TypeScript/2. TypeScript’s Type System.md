# CHAPTER 2 TypeScript’s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> 🚨 JS runtime에서 `typeof null`은 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

### TypeScript terms and set terms

| **TypeScript term**   | **Set term**            |
|-----------------------|-------------------------|
| never                 | ∅ (empty set)           |
| Literal type          | Single element set      |
| Value assignable to T | Value ∈ T (member of)   |
| T1 assignable to T2   | T1 ⊆ T2 (subset of)     |
| T1 extends T2         | T1 ⊆ T2 (subset of)     |
| T1 | T2               | T1 ∪ T2 (union)         |
| T1 & T2               | T1 ∩ T2 (intersection)  |
| unknown               | Universal set           |

### assignable = members of(values-types) or subset of(types-types)

- 결국 type checker가 하는 일의 대부분은 하나의 집합이 다른 집합의 부분집합인지 테스트하는 일

- `number[]`는 `[]` 와 `list[1]`도 가능하므로 `tuple`의 부분집합이 아님

```ts
const list = [1, 2]; // Type is number[]
const tuple: [number, number] = list;
// ~~~~~ Type 'number[]' is missing the following
// properties from type '[number, number]': 0, 1
```

- TS가 tuple을 length를 넣어 모델링 함
  - `{0: number, 1: number, length: 2}`

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple; 
// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

- `Exclude<UnionType, ExcludedMembers>`

```ts
type T = Exclude<string|Date, string|number>; // Type is Date
type NonZeroNums = Exclude<number, 0>; // Type is still just number
```

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space
>
> 📝 symbols?
>
> : a symbol is a unique identifier that is used to represent some entity within the program, such as a variable, function, or class.

- `InstanceType<Type>`: constructor type(function, `typeof Class`)을 넣어 instance type(object)을 얻을 수 있음

| Concept | Value Space | Type Space |
|---------|-------------|------------|
|`typeof`| returns a string containing the runtime type of the symbol | returns its TypeScript type|
| `this`  | JavaScript `this` keyword  | TypeScript type of `this` (aka "polymorphic this") |
| `&` and `\|` | Bitwise AND and OR | Intersection and union operators |
| `const` | Introduces a new variable | Changes the inferred type of a literal or literal expression |
| `extends` | Defines a subclass (`class A extends B`) or a subtype (`interface A extends B`) or a constraint on a generic type (`Generic<T extends number>`) | Defines a type constraint between types |
| `in` | Part of a loop (`for (key in object)`) | Mapped type|

- value space와 type space의 구분을 직접 확인하려면 TypeScript Playground를 이용하여 확인

## Item 9: Prefer Type Declarations to Type Assertions

> 🚨 `const bob = <Person>{}`
>
> `const bob = {} as Person`의 옛날방식
> TypeScript + React인 .tsx 파일에선 `<Person>`이 시작 태그로 해석되기 때문에 잘 쓰이지 않음

### arrow function의 return type 정하기

```ts
interface Person { name: string };

const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]

// ❌
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]

// ✅
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);
```

- type assertion을 사용하면 type error가 있어도 잡아내지 못함

  ```ts
  const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
  // No error
  ```

### 언제 type assertion을 써야 하나

- type checker보다 그 type에 대해 확실히 알 때만 사용(type checker는 접근할 수 없는 context인 경우)
  - TS는 DOM에 접근할 수 없음

  ```ts
  document.querySelector('#myButton').addEventListener('click', e => {
    e.currentTarget // Type is EventTarget
    const button = e.currentTarget as HTMLButtonElement;
    button // Type is HTMLButtonElement
  });
  ```

- `null`이 아님을 확신할 수 있을 때만 non-null assertion(`!`)을 사용하고 아니면 조건문으로 `null`을 체크하는 할 것

### type assertion은 원래 type의 subset 중에서만 사용 가능

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'
// may be a mistake because neither type sufficiently
// overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first
```

- 억지로 바꾸고 싶다면 `unknown`을 중간에 섞어야 함
  - 모든 type은 `unknown`의 subtype이기 때문에 가능

```ts
const el = document.body as unknown as Person; // OK
```

## Item 10: Avoid Object Wrapper Types (`String`, `Number`, `Boolean`, `Symbol`, `BigInt`)

### Object Wrapper를 instantiate하거나 직접 사용하지 않기

- built-in method 확인하기

  - 여기서 `this`는 `String` object wrapper

 ```ts
 const originalCharAt = String.prototype.charAt;
 String.prototype.charAt = function(pos) {
   console.log(this, typeof this, pos);
   return originalCharAt.call(this, pos);
 };
 console.log('primitive'.charAt(3));
 // [String: 'primitive'] 'object' 3
 // m
 ```

- primitive string에 property를 할당하면 해당 property가 사라져버림

```ts
x = "hello"
x.language = 'English'
// 'English'
x.language
// undefined
```

- object wrapper는 primitive value에 편의를 위한 method와 static method를 제공하기 위해 존재함
- object wrapper에 primitive value를 할당할 수 있지만 그 반대는 안됨

> 📝 `BigInt`와 `Symbol`은 `new` 없이 사용가능  
> primitive value를 만들기 때문에  
> ex) typeof BigInt(1234) // bigint
>
## Item 11: Recognize the Limits of Excess Property Checking

### Excess Property Checking이 수행되는 조건

- object literal을 variable이나 argument에 직접 할당할 때
  - but, type assertion을 사용하면 excess property checking 생략
- object literal을 어떤 중간 variable에 넣은 뒤에 넘기면 excess property checking은 수행되지 않음
- regular assignability check와는 별개의 프로세스로 취급하기

> 📝 Why do excess property checks be performed only when assigning object literals in TypeScript?
> Excess property checks are not performed when you assign an object that was created using a constructor function or an object that was obtained from another source, such as a database or an API response. This is because TypeScript assumes that the properties of these objects have already been checked by the constructor or the data source, and therefore does not perform any additional checks.
> By performing excess property checks only when assigning object literals, TypeScript helps catch a common class of errors that are caused by typos or programming mistakes, while also avoiding unnecessary checks for objects that are likely to have been previously validated.

## Item 12: Apply Types to Entire Function Expressions When Possible

- function *statement* 대신 function *expression*을 사용하면 type declaration을 function 전체에 적용할 수 있음

### 반복을 줄이기 위해 사용

- library에서 정의된 type을 가져다 쓸 때 parameter와 return type을 각각 가져다 쓰지말고 function을 통째로 가져다 쓸 것
  - ReactJS는 parameter를 위한 `MouseEvent`와 function을 위한 `MouseEventHandler`를 제공 -> `MouseEventHandler`를 쓰자
  - library를 만든다면 common callback을 위한 type declaration을 제공하자

### 다른 어떤 function의 signature와 일치시키기 위해 사용

- 다른 function의 signature와 matching 할 때는 `typeof fn`을 사용하자

> 📝 signatures?
> : a unique identifier for the function or method, based on its name and the types of its arguments and return values. A function's signature includes the function name and the number and types of its parameters, but not the implementation or the code inside the function.

> 🚨 `fetch()`의 error response는 rejected Promise가 아님
> request가 실패했을 때 response의 body는 JSON이 아닌 "404 Not Found"같은 text임
> 따라서 그냥 `response.json()`하면 404같은 응답코드와 그 내용을 받는 것이 아닌 "invalid JSON"이라는 에러가 나타남

```ts
// ❌
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
return quote;
}

declare function fetch(
input: RequestInfo, init?: RequestInit
): Promise<Response>;

// 🤔
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
const response = await fetch(input, init);
if (!response.ok) {
  // Converted to a rejected Promise in an async function
  throw new Error('Request failed: ' + response.status);
}
  return response;
}

// ✅
const checkedFetch: typeof fetch = async (input, init) => {
const response = await fetch(input, init);
  if (!response.ok) {
  throw new Error('Request failed: ' + response.status);
}
  return response;
}
```

- return type도 보장해줌

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  // ~~~~~~~~~~~~ Type 'Promise<Response | HTTPError>'
  // is not assignable to type 'Promise<Response>'
  // Type 'Response | HTTPError' is not assignable
  // to type 'Response'
  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error('Request failed: ' + response.status);
  }
    return response;
}
```

## Item 13: Know the Differences Between `type` and `interface`

> 🚨 `I` prefix를 사용하지 말자
> 요즘엔 나쁜 스타일로 여겨짐. 불필요하고 standard library들이 일관되게 따르지 않음

### 둘다 할 수 있는 것

- excess property checking
- using index signatures
- defining function type
  - type alias가 더 자연스러움

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
```

- using generic
- extending types
  - `interface`와 `type`는 서로를 extend 가능

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number; };
```

- class는 둘다 `implements` 가능

### `type`만 할 수 있는 것

- union types
  - union types와 `interface` 조합하여 variable map 만들기

  ```ts
  type Input = {
    x: number;
    y: number;
  };

  type Output = {
    result: number;
  };

  interface VariableMap {
    [name: string]: Input | Output;
  }

  type NamedVariable = (Input | Output) & { name: string };

  const input1: Input = { x: 1, y: 2 };
  const output1: Output = { result: 3 };

  const variableMap: VariableMap = {
    'input1': input1,
    'output1': output1,
  };

  const namedVariable: NamedVariable = { name: 'input1', ...input1 };
  console.log(namedVariable) // { "name": "input1", "x": 1, "y": 2 } 
  ```

- mapped or conditional types

> 📝 mapped types
> : A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.
>
>   ```ts
>   type OptionsFlags<Type> = {
>     [Property in keyof Type]: boolean;
>   };
>   ```

> 📝 conditional types
> : A type construct that allows you to define a type based on a condition. They are used to create flexible and reusable type definitions that can handle different scenarios based on the properties of the input types.
>
>   ```ts
>   SomeType extends OtherType ? TrueType : FalseType
>   ```
>
- tuple
  - `interface`로도 구현 가능하지만 영 이상하고 array method들를 사용못하게 되므로 사용하지 말 것

  ```ts
  // 🤔
  interface Tuple {
    0: number;
    1: number;
    length: 2;
  }
  const t: Tuple = [10, 20];
  ```

### `interface`만 할 수 있는 것

- declaration merging(augment)
  - 주로 declaration file에서 사용됨
  - type declaration을 만든 사람과 그 것을 사용하는 사람이 원하는 type에 gap이 있을 때 필요한 것을 추가하여 합칠 수 있음
  - TS는 JS's standard library의 version에 따라 다른 type들을 가져오기 위해 이를 사용함
    - 예를 들어 default로 `lib.es5.d.ts`를 사용하고 그러면 ES6이전의 `Array` method들만 포함된 interface가 들어있음
    - `tsconfig.json`의 `lib` entry에 'ES2015`를 추가한다면`lib.es2015.d.ts`를 같이 포함시켜`Array` interface가 merge되어 `find()`같은 ES6이후 method들도 쓸 수 있게 됨
  - 다른 누군가 type을 augment하는 걸 원하지 않는다면 `interface`대신 `type`을 사용

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}
const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 500_000
}; // OK
```

### 둘 중 어떤 걸 사용해야 하나?

- 복잡한 type이면?
  - `type` 사용
- 비교적 간단한 type이여서 둘다 구현 가능하면?
  - consistency와 augmentation을 고려하여 결정
  - 기존 codebase에서 정해진 스타일대로 따라가자
    - 정해진 스타일이 없다면?
      - for external(API 등): `interface`
      - for internal: `type`

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

## Item 15: Use Index Signatures for Dynamic Data

## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

## Item 17: Use readonly to Avoid Errors Associated with Mutation

## Item 18: Use Mapped Types to Keep Values in Sync
