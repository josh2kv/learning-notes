# CHAPTER 2 TypeScriptâ€™s Type System

## Item 6: Use Your Editor to Interrogate and Explore the Type System

> ğŸš¨ JS runtimeì—ì„œ `typeof null`ì€ 'object`
>
> ```ts
> function getElement(elOrId: string|HTMLElement|null): HTMLElement {
>   if (typeof elOrId === 'object') {
>     return elOrId;
>     // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   } else if (elOrId === null) {
>     return document.body;
>   } else {
>     const el = document.getElementById(elOrId);
>     return el;
>     // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'
>   }
> }
> ```

## Item 7: Think of Types as Sets of Values

### TypeScript terms and set terms

| **TypeScript term**   | **Set term**            |
|-----------------------|-------------------------|
| never                 | âˆ… (empty set)           |
| Literal type          | Single element set      |
| Value assignable to T | Value âˆˆ T (member of)   |
| T1 assignable to T2   | T1 âŠ† T2 (subset of)     |
| T1 extends T2         | T1 âŠ† T2 (subset of)     |
| T1 | T2               | T1 âˆª T2 (union)         |
| T1 & T2               | T1 âˆ© T2 (intersection)  |
| unknown               | Universal set           |

### assignable = members of(values-types) or subset of(types-types)

- ê²°êµ­ type checkerê°€ í•˜ëŠ” ì¼ì˜ ëŒ€ë¶€ë¶„ì€ í•˜ë‚˜ì˜ ì§‘í•©ì´ ë‹¤ë¥¸ ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì¸ì§€ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì¼

- `number[]`ëŠ” `[]` ì™€ `list[1]`ë„ ê°€ëŠ¥í•˜ë¯€ë¡œ `tuple`ì˜ ë¶€ë¶„ì§‘í•©ì´ ì•„ë‹˜

```ts
const list = [1, 2]; // Type is number[]
const tuple: [number, number] = list;
// ~~~~~ Type 'number[]' is missing the following
// properties from type '[number, number]': 0, 1
```

- TSê°€ tupleì„ lengthë¥¼ ë„£ì–´ ëª¨ë¸ë§ í•¨
  - `{0: number, 1: number, length: 2}`

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple; 
// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

- `Exclude<UnionType, ExcludedMembers>`

```ts
type T = Exclude<string|Date, string|number>; // Type is Date
type NonZeroNums = Exclude<number, 0>; // Type is still just number
```

## Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space
>
> ğŸ“ symbols?
>
> : a symbol is a unique identifier that is used to represent some entity within the program, such as a variable, function, or class.

- `InstanceType<Type>`: constructor type(function, `typeof Class`)ì„ ë„£ì–´ instance type(object)ì„ ì–»ì„ ìˆ˜ ìˆìŒ

| Concept | Value Space | Type Space |
|---------|-------------|------------|
|`typeof`| returns a string containing the runtime type of the symbol | returns its TypeScript type|
| `this`  | JavaScript `this` keyword  | TypeScript type of `this` (aka "polymorphic this") |
| `&` and `\|` | Bitwise AND and OR | Intersection and union operators |
| `const` | Introduces a new variable | Changes the inferred type of a literal or literal expression |
| `extends` | Defines a subclass (`class A extends B`) or a subtype (`interface A extends B`) or a constraint on a generic type (`Generic<T extends number>`) | Defines a type constraint between types |
| `in` | Part of a loop (`for (key in object)`) | Mapped type|

- value spaceì™€ type spaceì˜ êµ¬ë¶„ì„ ì§ì ‘ í™•ì¸í•˜ë ¤ë©´ TypeScript Playgroundë¥¼ ì´ìš©í•˜ì—¬ í™•ì¸

## Item 9: Prefer Type Declarations to Type Assertions

> ğŸš¨ `const bob = <Person>{}`
>
> `const bob = {} as Person`ì˜ ì˜›ë‚ ë°©ì‹
> TypeScript + Reactì¸ .tsx íŒŒì¼ì—ì„  `<Person>`ì´ ì‹œì‘ íƒœê·¸ë¡œ í•´ì„ë˜ê¸° ë•Œë¬¸ì— ì˜ ì“°ì´ì§€ ì•ŠìŒ

### arrow functionì˜ return type ì •í•˜ê¸°

```ts
interface Person { name: string };

const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]

// âŒ
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]

// âœ…
const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
);
```

- type assertionì„ ì‚¬ìš©í•˜ë©´ type errorê°€ ìˆì–´ë„ ì¡ì•„ë‚´ì§€ ëª»í•¨

  ```ts
  const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
  // No error
  ```

### ì–¸ì œ type assertionì„ ì¨ì•¼ í•˜ë‚˜

- type checkerë³´ë‹¤ ê·¸ typeì— ëŒ€í•´ í™•ì‹¤íˆ ì•Œ ë•Œë§Œ ì‚¬ìš©(type checkerëŠ” ì ‘ê·¼í•  ìˆ˜ ì—†ëŠ” contextì¸ ê²½ìš°)
  - TSëŠ” DOMì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ

  ```ts
  document.querySelector('#myButton').addEventListener('click', e => {
    e.currentTarget // Type is EventTarget
    const button = e.currentTarget as HTMLButtonElement;
    button // Type is HTMLButtonElement
  });
  ```

- `null`ì´ ì•„ë‹˜ì„ í™•ì‹ í•  ìˆ˜ ìˆì„ ë•Œë§Œ non-null assertion(`!`)ì„ ì‚¬ìš©í•˜ê³  ì•„ë‹ˆë©´ ì¡°ê±´ë¬¸ìœ¼ë¡œ `null`ì„ ì²´í¬í•˜ëŠ” í•  ê²ƒ

### type assertionì€ ì›ë˜ typeì˜ subset ì¤‘ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'
// may be a mistake because neither type sufficiently
// overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first
```

- ì–µì§€ë¡œ ë°”ê¾¸ê³  ì‹¶ë‹¤ë©´ `unknown`ì„ ì¤‘ê°„ì— ì„ì–´ì•¼ í•¨
  - ëª¨ë“  typeì€ `unknown`ì˜ subtypeì´ê¸° ë•Œë¬¸ì— ê°€ëŠ¥

```ts
const el = document.body as unknown as Person; // OK
```

## Item 10: Avoid Object Wrapper Types (`String`, `Number`, `Boolean`, `Symbol`, `BigInt`)

### Object Wrapperë¥¼ instantiateí•˜ê±°ë‚˜ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šê¸°

- built-in method í™•ì¸í•˜ê¸°

  - ì—¬ê¸°ì„œ `this`ëŠ” `String` object wrapper

 ```ts
 const originalCharAt = String.prototype.charAt;
 String.prototype.charAt = function(pos) {
   console.log(this, typeof this, pos);
   return originalCharAt.call(this, pos);
 };
 console.log('primitive'.charAt(3));
 // [String: 'primitive'] 'object' 3
 // m
 ```

- primitive stringì— propertyë¥¼ í• ë‹¹í•˜ë©´ í•´ë‹¹ propertyê°€ ì‚¬ë¼ì ¸ë²„ë¦¼

```ts
x = "hello"
x.language = 'English'
// 'English'
x.language
// undefined
```

- object wrapperëŠ” primitive valueì— í¸ì˜ë¥¼ ìœ„í•œ methodì™€ static methodë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ ì¡´ì¬í•¨
- object wrapperì— primitive valueë¥¼ í• ë‹¹í•  ìˆ˜ ìˆì§€ë§Œ ê·¸ ë°˜ëŒ€ëŠ” ì•ˆë¨

> ğŸ“ `BigInt`ì™€ `Symbol`ì€ `new` ì—†ì´ ì‚¬ìš©ê°€ëŠ¥  
> primitive valueë¥¼ ë§Œë“¤ê¸° ë•Œë¬¸ì—  
> ex) typeof BigInt(1234) // bigint
>
## Item 11: Recognize the Limits of Excess Property Checking

### Excess Property Checkingì´ ìˆ˜í–‰ë˜ëŠ” ì¡°ê±´

- object literalì„ variableì´ë‚˜ argumentì— ì§ì ‘ í• ë‹¹í•  ë•Œ
  - but, type assertionì„ ì‚¬ìš©í•˜ë©´ excess property checking ìƒëµ
- object literalì„ ì–´ë–¤ ì¤‘ê°„ variableì— ë„£ì€ ë’¤ì— ë„˜ê¸°ë©´ excess property checkingì€ ìˆ˜í–‰ë˜ì§€ ì•ŠìŒ
- regular assignability checkì™€ëŠ” ë³„ê°œì˜ í”„ë¡œì„¸ìŠ¤ë¡œ ì·¨ê¸‰í•˜ê¸°

> ğŸ“ Why do excess property checks be performed only when assigning object literals in TypeScript?
> Excess property checks are not performed when you assign an object that was created using a constructor function or an object that was obtained from another source, such as a database or an API response. This is because TypeScript assumes that the properties of these objects have already been checked by the constructor or the data source, and therefore does not perform any additional checks.
> By performing excess property checks only when assigning object literals, TypeScript helps catch a common class of errors that are caused by typos or programming mistakes, while also avoiding unnecessary checks for objects that are likely to have been previously validated.

## Item 12: Apply Types to Entire Function Expressions When Possible

- function *statement* ëŒ€ì‹  function *expression*ì„ ì‚¬ìš©í•˜ë©´ type declarationì„ function ì „ì²´ì— ì ìš©í•  ìˆ˜ ìˆìŒ

### ë°˜ë³µì„ ì¤„ì´ê¸° ìœ„í•´ ì‚¬ìš©

- libraryì—ì„œ ì •ì˜ëœ typeì„ ê°€ì ¸ë‹¤ ì“¸ ë•Œ parameterì™€ return typeì„ ê°ê° ê°€ì ¸ë‹¤ ì“°ì§€ë§ê³  functionì„ í†µì§¸ë¡œ ê°€ì ¸ë‹¤ ì“¸ ê²ƒ
  - ReactJSëŠ” parameterë¥¼ ìœ„í•œ `MouseEvent`ì™€ functionì„ ìœ„í•œ `MouseEventHandler`ë¥¼ ì œê³µ -> `MouseEventHandler`ë¥¼ ì“°ì
  - libraryë¥¼ ë§Œë“ ë‹¤ë©´ common callbackì„ ìœ„í•œ type declarationì„ ì œê³µí•˜ì

### ë‹¤ë¥¸ ì–´ë–¤ functionì˜ signatureì™€ ì¼ì¹˜ì‹œí‚¤ê¸° ìœ„í•´ ì‚¬ìš©

- ë‹¤ë¥¸ functionì˜ signatureì™€ matching í•  ë•ŒëŠ” `typeof fn`ì„ ì‚¬ìš©í•˜ì

> ğŸ“ signatures?
> : a unique identifier for the function or method, based on its name and the types of its arguments and return values. A function's signature includes the function name and the number and types of its parameters, but not the implementation or the code inside the function.

> ğŸš¨ `fetch()`ì˜ error responseëŠ” rejected Promiseê°€ ì•„ë‹˜
> requestê°€ ì‹¤íŒ¨í–ˆì„ ë•Œ responseì˜ bodyëŠ” JSONì´ ì•„ë‹Œ "404 Not Found"ê°™ì€ textì„
> ë”°ë¼ì„œ ê·¸ëƒ¥ `response.json()`í•˜ë©´ 404ê°™ì€ ì‘ë‹µì½”ë“œì™€ ê·¸ ë‚´ìš©ì„ ë°›ëŠ” ê²ƒì´ ì•„ë‹Œ "invalid JSON"ì´ë¼ëŠ” ì—ëŸ¬ê°€ ë‚˜íƒ€ë‚¨

```ts
// âŒ
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain');
  const quote = await response.json();
return quote;
}

declare function fetch(
input: RequestInfo, init?: RequestInit
): Promise<Response>;

// ğŸ¤”
async function checkedFetch(input: RequestInfo, init?: RequestInit) {
const response = await fetch(input, init);
if (!response.ok) {
  // Converted to a rejected Promise in an async function
  throw new Error('Request failed: ' + response.status);
}
  return response;
}

// âœ…
const checkedFetch: typeof fetch = async (input, init) => {
const response = await fetch(input, init);
  if (!response.ok) {
  throw new Error('Request failed: ' + response.status);
}
  return response;
}
```

- return typeë„ ë³´ì¥í•´ì¤Œ

```ts
const checkedFetch: typeof fetch = async (input, init) => {
  // ~~~~~~~~~~~~ Type 'Promise<Response | HTTPError>'
  // is not assignable to type 'Promise<Response>'
  // Type 'Response | HTTPError' is not assignable
  // to type 'Response'
  const response = await fetch(input, init);
  if (!response.ok) {
    return new Error('Request failed: ' + response.status);
  }
    return response;
}
```

## Item 13: Know the Differences Between `type` and `interface`

> ğŸš¨ `I` prefixë¥¼ ì‚¬ìš©í•˜ì§€ ë§ì
> ìš”ì¦˜ì—” ë‚˜ìœ ìŠ¤íƒ€ì¼ë¡œ ì—¬ê²¨ì§. ë¶ˆí•„ìš”í•˜ê³  standard libraryë“¤ì´ ì¼ê´€ë˜ê²Œ ë”°ë¥´ì§€ ì•ŠìŒ

### ë‘˜ë‹¤ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- excess property checking
- using index signatures
- defining function type
  - type aliasê°€ ë” ìì—°ìŠ¤ëŸ¬ì›€

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
```

- using generic
- extending types
  - `interface`ì™€ `type`ëŠ” ì„œë¡œë¥¼ extend ê°€ëŠ¥

```ts
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number; };
```

- classëŠ” ë‘˜ë‹¤ `implements` ê°€ëŠ¥

### `type`ë§Œ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- union types
  - union typesì™€ `interface` ì¡°í•©í•˜ì—¬ variable map ë§Œë“¤ê¸°

  ```ts
  type Input = {
    x: number;
    y: number;
  };

  type Output = {
    result: number;
  };

  interface VariableMap {
    [name: string]: Input | Output;
  }

  type NamedVariable = (Input | Output) & { name: string };

  const input1: Input = { x: 1, y: 2 };
  const output1: Output = { result: 3 };

  const variableMap: VariableMap = {
    'input1': input1,
    'output1': output1,
  };

  const namedVariable: NamedVariable = { name: 'input1', ...input1 };
  console.log(namedVariable) // { "name": "input1", "x": 1, "y": 2 } 
  ```

- mapped or conditional types

> ğŸ“ mapped types
> : A mapped type is a generic type which uses a union of PropertyKeys (frequently created via a keyof) to iterate through keys to create a type.
>
>   ```ts
>   type OptionsFlags<Type> = {
>     [Property in keyof Type]: boolean;
>   };
>   ```

> ğŸ“ conditional types
> : A type construct that allows you to define a type based on a condition. They are used to create flexible and reusable type definitions that can handle different scenarios based on the properties of the input types.
>
>   ```ts
>   SomeType extends OtherType ? TrueType : FalseType
>   ```
>
- tuple
  - `interface`ë¡œë„ êµ¬í˜„ ê°€ëŠ¥í•˜ì§€ë§Œ ì˜ ì´ìƒí•˜ê³  array methodë“¤ë¥¼ ì‚¬ìš©ëª»í•˜ê²Œ ë˜ë¯€ë¡œ ì‚¬ìš©í•˜ì§€ ë§ ê²ƒ

  ```ts
  // ğŸ¤”
  interface Tuple {
    0: number;
    1: number;
    length: 2;
  }
  const t: Tuple = [10, 20];
  ```

### `interface`ë§Œ í•  ìˆ˜ ìˆëŠ” ê²ƒ

- declaration merging(augment)
  - ì£¼ë¡œ declaration fileì—ì„œ ì‚¬ìš©ë¨
  - type declarationì„ ë§Œë“  ì‚¬ëŒê³¼ ê·¸ ê²ƒì„ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì´ ì›í•˜ëŠ” typeì— gapì´ ìˆì„ ë•Œ í•„ìš”í•œ ê²ƒì„ ì¶”ê°€í•˜ì—¬ í•©ì¹  ìˆ˜ ìˆìŒ
  - TSëŠ” JS's standard libraryì˜ versionì— ë”°ë¼ ë‹¤ë¥¸ typeë“¤ì„ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ì´ë¥¼ ì‚¬ìš©í•¨
    - ì˜ˆë¥¼ ë“¤ì–´ defaultë¡œ `lib.es5.d.ts`ë¥¼ ì‚¬ìš©í•˜ê³  ê·¸ëŸ¬ë©´ ES6ì´ì „ì˜ `Array` methodë“¤ë§Œ í¬í•¨ëœ interfaceê°€ ë“¤ì–´ìˆìŒ
    - `tsconfig.json`ì˜ `lib` entryì— 'ES2015`ë¥¼ ì¶”ê°€í•œë‹¤ë©´`lib.es2015.d.ts`ë¥¼ ê°™ì´ í¬í•¨ì‹œì¼œ`Array` interfaceê°€ mergeë˜ì–´ `find()`ê°™ì€ ES6ì´í›„ methodë“¤ë„ ì“¸ ìˆ˜ ìˆê²Œ ë¨
  - ë‹¤ë¥¸ ëˆ„êµ°ê°€ typeì„ augmentí•˜ëŠ” ê±¸ ì›í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `interface`ëŒ€ì‹  `type`ì„ ì‚¬ìš©

```ts
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}
const wyoming: IState = {
  name: 'Wyoming',
  capital: 'Cheyenne',
  population: 500_000
}; // OK
```

### ë‘˜ ì¤‘ ì–´ë–¤ ê±¸ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜?

- ë³µì¡í•œ typeì´ë©´?
  - `type` ì‚¬ìš©
- ë¹„êµì  ê°„ë‹¨í•œ typeì´ì—¬ì„œ ë‘˜ë‹¤ êµ¬í˜„ ê°€ëŠ¥í•˜ë©´?
  - consistencyì™€ augmentationì„ ê³ ë ¤í•˜ì—¬ ê²°ì •
  - ê¸°ì¡´ codebaseì—ì„œ ì •í•´ì§„ ìŠ¤íƒ€ì¼ëŒ€ë¡œ ë”°ë¼ê°€ì
    - ì •í•´ì§„ ìŠ¤íƒ€ì¼ì´ ì—†ë‹¤ë©´?
      - for external(API ë“±): `interface`
      - for internal: `type`

## Item 14: Use Type Operations and Generics to Avoid Repeating Yourself

## Item 15: Use Index Signatures for Dynamic Data

## Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures

## Item 17: Use readonly to Avoid Errors Associated with Mutation

## Item 18: Use Mapped Types to Keep Values in Sync
