# 1. Getting to Know TypeScript

## Item 1: Understand the Relationship Between TypeScript and JavaScript

### TS는 JS의 superset(상위집합)

- 모든 JS app는 이미 TS app임
  - 따라서 JS에서 TS로 migration이 쉬움
- 대부분 TS app은 JS app이 아님(TS만의 syntax를 가지고 있기 때문에)

### TS는 JS의 runtime behavior를 modeling하는 type system을 추가하여 runtime에서 error를 발생시킬 수 있는 code를 찾음

> *Modeling* in software development  
> : creating an abstract representation of something in order to reason about it more easily  
> : creating a simplified representation of something complex to make it easier to understand and reason about

- 하지만 모든 exception을 찾아낼 수 있는 것은 아니므로 실제 runtime에서 error 발생 가능

  ```ts
  const names = ['Alice', 'Bob'];
  // TS는 error를 뱉지 않음
  console.log(names[2].toUpperCase());
  ```

- static type의 정확성을 보장하는 type system을 sound하다고 하는데 TS의 type system은 sound하지 않으며 그런 의도로 만들어진 것도 아님
  - 만약 sound하다면 TS는 JS의 superset이 아니며 JS에서 TS로 migration하는 것도 훨씬 복잡한 일이 될 것

### TS의 type system은 JS behavior를 대부분 modeling하지만 JS는 허용하지만 TS는 허용하지 않는 construct들이 있음

- `null`과 7 더하기, 더 많은 argument의 개수로 function을 call하는 것 등
- 대부분 취향의 문제

## Item 2: Know Which TypeScript Options You’re Using

### TS complier는 TS language 자체의 core 측면을 다루는 몇몇 설정을 포함

- 많은 TS 설정은 source file을 있는 장소, TS가 만들어내는 결과물의 종류등을 다룸
- `noImplicitAny`과 `strictNullChecks`와 같은 설정은 TS language의 core 측면에 영향을 줌
- JS에서 TS로 transition하는 것이 아니면 `noImplicitAny` on
- "undefined is not an object"같은 runtime error를 막고 싶다면 `strictNullChecks` on

### TS를 설정할 때는 command-line option말고 *tsconfig.json*을 사용할 것

### TS가 제공할 수 있는 완전한 checking을 얻기 위해 `strict`를 켜는 것을 목표로 하기

## Item 3: Understand That Code Generation Is Independent of Types

## Item 4: Get Comfortable with Structural Typing

## Item 5: Limit Use of the any Type
