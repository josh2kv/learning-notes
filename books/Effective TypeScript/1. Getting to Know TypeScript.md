# 1. Getting to Know TypeScript

## Item 1: Understand the Relationship Between TypeScript and JavaScript

### TSëŠ” JSì˜ superset(ìƒìœ„ì§‘í•©)

- ëª¨ë“  JS appëŠ” ì´ë¯¸ TS appì„
  - ë”°ë¼ì„œ JSì—ì„œ TSë¡œ migrationì´ ì‰¬ì›€
- ëŒ€ë¶€ë¶„ TS appì€ JS appì´ ì•„ë‹˜(TSë§Œì˜ syntaxë¥¼ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì—)

### TSëŠ” JSì˜ runtime behaviorë¥¼ modelingí•˜ëŠ” type systemì„ ì¶”ê°€í•˜ì—¬ runtimeì—ì„œ errorë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆëŠ” codeë¥¼ ì°¾ìŒ

> *Modeling* in software development  
> : creating an abstract representation of something in order to reason about it more easily  
> : creating a simplified representation of something complex to make it easier to understand and reason about

- í•˜ì§€ë§Œ ëª¨ë“  exceptionì„ ì°¾ì•„ë‚¼ ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë‹ˆë¯€ë¡œ ì‹¤ì œ runtimeì—ì„œ error ë°œìƒ ê°€ëŠ¥

  ```ts
  const names = ['Alice', 'Bob'];
  // TSëŠ” errorë¥¼ ë±‰ì§€ ì•ŠìŒ
  console.log(names[2].toUpperCase());
  ```

- static typeì˜ ì •í™•ì„±ì„ ë³´ì¥í•˜ëŠ” type systemì„ soundí•˜ë‹¤ê³  í•˜ëŠ”ë° TSì˜ type systemì€ soundí•˜ì§€ ì•Šìœ¼ë©° ê·¸ëŸ° ì˜ë„ë¡œ ë§Œë“¤ì–´ì§„ ê²ƒë„ ì•„ë‹˜
  - ë§Œì•½ soundí•˜ë‹¤ë©´ TSëŠ” JSì˜ supersetì´ ì•„ë‹ˆë©° JSì—ì„œ TSë¡œ migrationí•˜ëŠ” ê²ƒë„ í›¨ì”¬ ë³µì¡í•œ ì¼ì´ ë  ê²ƒ

### TSì˜ type systemì€ JS behaviorë¥¼ ëŒ€ë¶€ë¶„ modelingí•˜ì§€ë§Œ JSëŠ” í—ˆìš©í•˜ì§€ë§Œ TSëŠ” í—ˆìš©í•˜ì§€ ì•ŠëŠ” constructë“¤ì´ ìˆìŒ

- `null`ê³¼ 7 ë”í•˜ê¸°, ë” ë§ì€ argumentì˜ ê°œìˆ˜ë¡œ functionì„ callí•˜ëŠ” ê²ƒ ë“±
- ëŒ€ë¶€ë¶„ ì·¨í–¥ì˜ ë¬¸ì œ

## Item 2: Know Which TypeScript Options Youâ€™re Using

### TS complierëŠ” TS language ìì²´ì˜ core ì¸¡ë©´ì„ ë‹¤ë£¨ëŠ” ëª‡ëª‡ ì„¤ì •ì„ í¬í•¨

- ë§ì€ TS ì„¤ì •ì€ source fileì„ ìˆëŠ” ì¥ì†Œ, TSê°€ ë§Œë“¤ì–´ë‚´ëŠ” ê²°ê³¼ë¬¼ì˜ ì¢…ë¥˜ë“±ì„ ë‹¤ë£¸
- `noImplicitAny`ê³¼ `strictNullChecks`ì™€ ê°™ì€ ì„¤ì •ì€ TS languageì˜ core ì¸¡ë©´ì— ì˜í–¥ì„ ì¤Œ
- JSì—ì„œ TSë¡œ transitioní•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë©´ `noImplicitAny` on
- "undefined is not an object"ê°™ì€ runtime errorë¥¼ ë§‰ê³  ì‹¶ë‹¤ë©´ `strictNullChecks` on

### TSë¥¼ ì„¤ì •í•  ë•ŒëŠ” command-line optionë§ê³  *tsconfig.json*ì„ ì‚¬ìš©í•  ê²ƒ

### TSê°€ ì œê³µí•  ìˆ˜ ìˆëŠ” ì™„ì „í•œ checkingì„ ì–»ê¸° ìœ„í•´ `strict`ë¥¼ ì¼œëŠ” ê²ƒì„ ëª©í‘œë¡œ í•˜ê¸°

## Item 3: Understand That Code Generation Is Independent of Types

### type errorë¥¼ í¬í•¨í•˜ëŠ” codeë„ compileí•˜ì—¬ JS outputì„ ë§Œë“¤ ìˆ˜ ìˆìŒ

- C ë˜ëŠ” Javaì™€ ê°™ì€ ì–¸ì–´ì—ì„œëŠ” ë¶ˆê°€ëŠ¥
- `noEmitOnError` ì˜µì…˜ì„ ì‚¬ìš©í•˜ì—¬ compileì„ ë§‰ì„ ìˆ˜ ìˆìŒ

### typeë“¤ì€ compileì‹œ ëª¨ë‘ ì§€ì›Œì§€ë¯€ë¡œ runtimeì—ì„œ ì ‘ê·¼ ë¶ˆê°€ëŠ¥í•˜ì—¬ runtimeì—ì„œ typeì„ í™œìš©í•˜ê³  ì‹¶ë‹¤ë©´ ë‹¤ë¥¸ ë°©ë²•ì„ ì¨ì•¼í•¨

- property ìœ ë¬´ ì²´í¬í•˜ê¸°

  ```ts
  function calculateArea(shape: Shape) {
    if ('height' in shape) {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width;
    }
  }
    ```

  - typeì— tagë¥¼ ì €ì¥í•˜ì—¬ ì´ìš©í•˜ê¸°

  ```ts
  interface Square {
    kind: 'square';
    width: number;
  }
  interface Rectangle {
    kind: 'rectangle';
    height: number;
    width: number;
  }
  // This is "tagged union"
  type Shape = Square | Rectangle;

  function calculateArea(shape: Shape) {
    if (shape.kind === 'rectangle') {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width;
    }
  }
  ```

- class ì´ìš©í•˜ê¸°

  ```ts
  class Square {
    constructor(public width: number) {}
  }
  class Rectangle extends Square {
    constructor(public width: number, public height: number) {
      super(width);
    }
  }
  type Shape = Square | Rectangle;

  function calculateArea(shape: Shape) {
    if (shape instanceof Rectangle) {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width; // OK
    }
  }
  ```

### type operationì€ runtime valueì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒ

  ```ts
  //  before compiling(in TS)
  function asNumber(val: number | string): number {
    return val as number;
  }

  // after compiling(in JS)
  function asNumber(val) {
    return val;
  }

  // runtime valueì—ë„ typeì„ ê°•ì œí•˜ê³  ì‹¶ë‹¤ë©´ ì§ì ‘ êµ¬í˜„í•´ì•¼ í•¨
  function asNumber(val: number | string): number {
    return typeof(val) === 'string' ? Number(val) : val;
  }
  ```

### runtime typeì€ declared typeê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ

- ì•„ë˜ codeì—ì„œ logëŠ” runtimeì—ì„œ ì‹¤í–‰ë  ìˆ˜ ìˆìŒ

  ```ts
  function setLightSwitch(value: boolean) {
    switch (value) {
      case true:
      turnLightOn();
    break;
      case false:
      turnLightOff();
    break;
    // valueëŠ” ì‚¬ìš©ìê°€ ì…ë ¥í•œ ê°’ì´ê±°ë‚˜ network responseì¼ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ booleanì„ì„ ê°•ì œí•  ë°©ë²•ì€ ì—†ìŒ
    default:
      console.log(`I'm afraid I can't do that.`);
    }
  }
  ```

### TSì˜ typeìœ¼ë¡œ function overloading ë¶ˆê°€

### TSì˜ typeì€ runtime performanceì— ì˜í–¥ ì•ˆì¤Œ

- buildê°€ ë„ˆë¬´ ì˜¤ë˜ ê±¸ë¦°ë‹¤ë©´ "transpile only" ì˜µì…˜ìœ¼ë¡œ type checkingì„ ìƒëµí•  ìˆ˜ ìˆìŒ
- êµ¬í˜• runtimeì„ ì§€ì›í•˜ë„ë¡ compileëœ ê²°ê³¼ë¬¼ì´ native implementationê³¼ performance ì°¨ì´ë¥¼ ë³´ì¸ë‹¤ë©´ emit targetê³¼ language levelì„ ë°”ê¿”ë³´ê¸°

## Item 4: Get Comfortable with Structural Typing

### Types are not "sealed"

- ì–´ë–¤ interfaceì— assignableí•œ variableì€ ê·¸ interfaceì— ì •ì˜ëœ propertyë“¤ë³´ë‹¤ ë” ë§ì€ propertyë¥¼ ë³´ìœ í•˜ê³ ì„œ í• ë‹¹ë  ìˆ˜ ìˆìŒì— ìœ ì˜(types are not "sealed")

```ts
interface Vector2D {
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

const v: NamedVector = { x: 3, y: 4, name: 'Zee' };
calculateLength(v); // OK, result is 5
```

- ë‹¤ìŒ ì½”ë“œì— ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ì´ìœ ëŠ”?
  - `v`ì—ëŠ” `Vector3D`ì˜ ìƒìœ„ ì§‘í•©ì— í•´ë‹¹í•˜ëŠ” typeì´ ë“¤ì–´ê°ˆ ìˆ˜ ìˆê¸° ë•Œë¬¸ì—
  - ë”°ë¼ì„œ `axis`ì—ëŠ” `v`ì˜ ì—¬ë¶„ propertyì— í•´ë‹¹í•˜ëŠ” ì–´ë–¤ stringë„ ë“¤ì–´ ê°ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ `v[axis]` ë˜í•œ numberë¼ëŠ” ë³´ì¥ì´ ì—†ê¸° ë•Œë¬¸ì— `coord`ì˜ typeì€ `any`ê°€ ë¨

```ts
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
function calculateLengthL1(v: Vector3D) {
  let length = 0;

  for (const axis of Object.keys(v)) {
    const coord = v[axis];
    // ~~~~~~~ Element implicitly has an 'any' type because ...
    // 'string' can't be used to index type 'Vector3D'
    length += Math.abs(coord);
  }

  return length;
}

const vec3D = {x: 3, y: 4, z: 1, address: '123 Broadway'};
calculateLengthL1(vec3D); // OK, returns NaN

// ì´ë ‡ê²Œ ì‘ì„±í•´ì•¼ í•¨
function calculateLengthL1(v: Vector3D) {
  return Math.abs(v.x) + Math.abs(v.y) + Math.abs(v.z);
}
```

### class typeì— ê·¸ instanceê°€ ì•„ë‹Œ typeë“¤ì´ í• ë‹¹ë  ìˆ˜ ìˆìŒì— ìœ ì˜

```ts
class C {
  foo: string;
  constructor(foo: string) {
    this.foo = foo;
  }
}

const c = new C('instance of C');
const d: C = { foo: 'object literal' }; // OK!
```

### structural typingì€ test codeë¥¼ ì‘ì„±í•  ë•Œ ìœ ë¦¬í•¨

- ì§„ì§œ DB interfaceë¥¼ ì •ì˜í•˜ëŠ” ëŒ€ì‹  narrower interfaceë¥¼ ì •ì˜
- testì‹œ mocking library ë“±ìœ¼ë¡œ DBë¥¼ ë§Œë“¤ì–´ì„œ ë„˜ê²¨ì¤„ í•„ìš”ì—†ì´ ì´ë¥¼ ê°„ë‹¨í•œ objectë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆìŒ

```ts
interface Author {
  first: string;
  last: string;
}

function getAuthors(database: PostgresDB): Author[] {
  const authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);
  return authorRows.map(row => ({first: row[0], last: row[1]}));
}

ğŸ”½

interface DB {
  runQuery: (sql: string) => any[];
}

function getAuthors(database: DB): Author[] {
  const authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);
  return authorRows.map(row => ({first: row[0], last: row[1]}));
}

// test code
test('getAuthors', () => {
  const authors = getAuthors({
    runQuery(sql: string) {
    return [['Toni', 'Morrison'], ['Maya', 'Angelou']];
  }
});

expect(authors).toEqual([
    {first: 'Toni', last: 'Morrison'},
    {first: 'Maya', last: 'Angelou'}
  ]);
});
```

## Item 5: Limit Use of the `any` Type

- `as any`(type assertion)ë¥¼ ë¶™í˜€ì„œ type errorë¥¼ ì§€ìš¸ ìˆ˜ ìˆìŒ

```ts
let age: number;
age = '12';
// ~~~ Type '"12"' is not assignable to type 'number'
age = '12' as any; // OK
```

### Thereâ€™s No Type Safety with `any` Types

### `any` Lets You Break Contracts

### There Are No Language Services for `any` Types

### `any` Hides Your Type Design

### `any` Undermines Confidence in the Type System
