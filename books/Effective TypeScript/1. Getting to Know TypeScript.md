# 1. Getting to Know TypeScript

## Item 1: Understand the Relationship Between TypeScript and JavaScript

### TS는 JS의 superset(상위집합)

- 모든 JS app는 이미 TS app임
  - 따라서 JS에서 TS로 migration이 쉬움
- 대부분 TS app은 JS app이 아님(TS만의 syntax를 가지고 있기 때문에)

### TS는 JS의 runtime behavior를 modeling하는 type system을 추가하여 runtime에서 error를 발생시킬 수 있는 code를 찾음

> *Modeling* in software development  
> : creating an abstract representation of something in order to reason about it more easily  
> : creating a simplified representation of something complex to make it easier to understand and reason about

- 하지만 모든 exception을 찾아낼 수 있는 것은 아니므로 실제 runtime에서 error 발생 가능

  ```ts
  const names = ['Alice', 'Bob'];
  // TS는 error를 뱉지 않음
  console.log(names[2].toUpperCase());
  ```

- static type의 정확성을 보장하는 type system을 sound하다고 하는데 TS의 type system은 sound하지 않으며 그런 의도로 만들어진 것도 아님
  - 만약 sound하다면 TS는 JS의 superset이 아니며 JS에서 TS로 migration하는 것도 훨씬 복잡한 일이 될 것

### TS의 type system은 JS behavior를 대부분 modeling하지만 JS는 허용하지만 TS는 허용하지 않는 construct들이 있음

- `null`과 7 더하기, 더 많은 argument의 개수로 function을 call하는 것 등
- 대부분 취향의 문제

## Item 2: Know Which TypeScript Options You’re Using

### TS complier는 TS language 자체의 core 측면을 다루는 몇몇 설정을 포함

- 많은 TS 설정은 source file을 있는 장소, TS가 만들어내는 결과물의 종류등을 다룸
- `noImplicitAny`과 `strictNullChecks`와 같은 설정은 TS language의 core 측면에 영향을 줌
- JS에서 TS로 transition하는 것이 아니면 `noImplicitAny` on
- "undefined is not an object"같은 runtime error를 막고 싶다면 `strictNullChecks` on

### TS를 설정할 때는 command-line option말고 *tsconfig.json*을 사용할 것

### TS가 제공할 수 있는 완전한 checking을 얻기 위해 `strict`를 켜는 것을 목표로 하기

## Item 3: Understand That Code Generation Is Independent of Types

- type error를 포함하는 code도 compile하여 JS output을 만들 수 있음
  - C 또는 Java와 같은 언어에서는 불가능
  - `noEmitOnError` 옵션을 사용하여 compile을 막을 수 있음
- type들은 compile시 모두 지워지므로 runtime에서 접근 불가능하여 다른 방법을 써야함
  - property 유무 체크하기

  ```ts
  function calculateArea(shape: Shape) {
    if ('height' in shape) {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width;
    }
  }
    ```

  - type에 tag를 저장하여 이용하기

  ```ts
  interface Square {
    kind: 'square';
    width: number;
  }
  interface Rectangle {
    kind: 'rectangle';
    height: number;
    width: number;
  }
  // This is "tagged union"
  type Shape = Square | Rectangle;

  function calculateArea(shape: Shape) {
    if (shape.kind === 'rectangle') {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width;
    }
  }
  ```

  - class 이용하기

  ```ts
  class Square {
    constructor(public width: number) {}
  }
  class Rectangle extends Square {
    constructor(public width: number, public height: number) {
      super(width);
    }
  }
  type Shape = Square | Rectangle;

  function calculateArea(shape: Shape) {
    if (shape instanceof Rectangle) {
      // Type is Rectangle
      return shape.width * shape.height;
    } else {
      // Type is Square
      return shape.width * shape.width; // OK
    }
  }
  ```

  - type operation은 runtime value에 영향을 주지 않음

  ```ts
  //  before compiling(in TS)
  function asNumber(val: number | string): number {
    return val as number;
  }

  // after compiling(in JS)
  function asNumber(val) {
    return val;
  }

  // runtime value에도 type을 강제하고 싶다면 직접 구현해야 함
  function asNumber(val: number | string): number {
    return typeof(val) === 'string' ? Number(val) : val;
  }
  ```

- runtime type은 declared type과 다를 수 있음
  - 아래 code에서 log는 runtime에서 실행될 수 있음

  ```ts
  function setLightSwitch(value: boolean) {
    switch (value) {
      case true:
      turnLightOn();
    break;
      case false:
      turnLightOff();
    break;
    // value는 사용자가 입력한 값이거나 network response일 수도 있으므로 boolean임을 강제할 방법은 없음
    default:
      console.log(`I'm afraid I can't do that.`);
    }
  }
  ```

- TS의 type으로 function overloading 불가
- TS의 type은 runtime performance에 영향 안줌
  - build가 너무 오래 걸린다면 "transpile only" 옵션으로 type checking을 생략할 수 있음
  - 구형 runtime을 지원하도록 compile된 결과물이 native implementation과 performance 차이를 보인다면 emit target과 language level을 바꿔보기

## Item 4: Get Comfortable with Structural Typing

## Item 5: Limit Use of the any Type
