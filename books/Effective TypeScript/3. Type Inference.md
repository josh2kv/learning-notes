# 3. Type Inference

> ğŸ“ *statically typedâ€ and â€œexplicitly typedâ€
>*statically typed*: a type checking system that occurs at compile-time
>*explicitly typed*: a programming language feature where the types of variables and expressions must be explicitly declared by the programmer.
> While these concepts are related, they are not the same thing. A language can be statically typed but not explicitly typed (e.g. C), or explicitly typed but not statically typed (e.g. Python). A language can also be both statically typed and explicitly typed (e.g. Java).

## Item 19: Avoid Cluttering Your Code with Inferable Types

- type annotationì´ ì“¸ë°ì—†ì´ ë§ìœ¼ë©´ refactorì‹œ ë¶ˆí¸

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

// ğŸ‘ bad
function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

// ğŸ‘ good
function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
```

- ì–´ë–¤ ì–¸ì–´ë“¤ì€ ì‚¬ìš©ì‹œì ì— parameterì˜ typeì„ ê²°ì •í•˜ê¸°ë„ í•˜ì§€ë§Œ TSì—ì„œ variableì˜ typeì€ ì²˜ìŒ ë§Œë“¤ì–´ì§ˆ ë•Œ ê²°ì •ë¨

### type annotationì´ ë¶ˆí•„ìš”í•œ ê²½ìš°(parameters)

- parameterì˜ default ê°’ì´ ì§€ì •ëœ ê²½ìš°
- ì–´ë–¤ functionì´ ì´ë¯¸ type annotationì„ ê°€ì§€ëŠ” libraryì— callbackìœ¼ë¡œ ë„˜ê²¨ì§€ëŠ” ê²½ìš°

```ts
// ğŸ‘ bad
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send('OK');
});

// ğŸ‘ good
app.get('/health', (request, response) => {
  response.send('OK');
});
```

### type annotationì´ í•„ìš”í•œ ê²½ìš°

#### object literalì„ ì‚¬ìš©í•  ë•Œ

- excess property checking ì‚¬ìš© ê°€ëŠ¥
- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const furby = {
    name: 'Furby',
    // ğŸ’¥ idì˜ typeì€ `string`
    id: 630509430963,
    price: 35,
  };
  logProduct(furby);
  // ~~~~~ Argument .. is not assignable to parameter of type 'Product'
  // Types of property 'id' are incompatible
  // Type 'number' is not assignable to type 'string'

  // ğŸ‘ good
  const furby: Product = {
    name: 'Furby',
    id: 630509430963,
    // ~~ Type 'number' is not assignable to type 'string'
    price: 35,
  };
  logProduct(furby);
  ```

#### a function's return type

- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string) {
    if (ticker in cache) {
      // ğŸ’¥ Promise.resolve(cache[ticker])ë¥¼ returní–ˆì–´ì•¼ í•¨
      return cache[ticker];
    }
    return fetch(`https://quotes.example.com/?q=${ticker}`)
      .then(response => response.json())
      .then(quote => {
        cache[ticker] = quote;
        return quote;
      });
  }
  getQuote('MSFT').then(considerBuying);
  // ~~~~ Property 'then' does not exist on type
  // 'number | Promise<any>'
  // Property 'then' does not exist on type 'number'

  // ğŸ‘ good
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string): Promise<number> {
    if (ticker in cache) {
      return cache[ticker];
      // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise<number>'
    }
    // ...
  }
  ```

- functionì„ ëª…í™•í•˜ê²Œ ì´í•´ì‹œì¼œì¤Œ
  - functionì„ êµ¬í˜„í•˜ê¸° ì „ì— inputê³¼ outputì„ ë¨¼ì € í™•ì‹¤íˆ í•˜ê³ (the function's contract, aka type signatureì„ ë¨¼ì € ì‘ì„±í•˜ê³ ) ì‹œì‘í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ(TDDì˜ ì •ì‹ )â­

> ğŸ“ test-driven development(TDD)
> : you write the tests that exercise a function before you implement it.

- named typeì„ ì‚¬ìš©í•˜ê²Œ í•´ì¤Œ

```ts
interface Vector2D { x: number; y: number; }
// ğŸ‘ bad
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y }; // type: { x: number; y: number; }
}
// ğŸ‘ good
function add(a: Vector2D, b: Vector2D): Vector2D {
  return { x: a.x + b.x, y: a.y + b.y }; // type: Vector2D
}
```

> ğŸ’¡ eslintì˜ `no-inferrable-types` ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ë¶ˆí•„ìš”í•œ type annotationì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ì¤Œ

## Item 20: Use Different Variables for Different Types

```ts
let id = "12-34-56";
fetchProduct(id);
id = 123456;
// ~~ '123456' is not assignable to type 'string'.
fetchProductBySerialNumber(id);
// ~~ Argument of type 'string' is not assignable to
// parameter of type 'number'

// ğŸ‘ bad
let id: string|number = "12-34-56";
fetchProduct(id);
id = 123456; 
fetchProductBySerialNumber(id); 

// ğŸ‘ good
const id = "12-34-56";
fetchProduct(id);
const serial = 123456; // OK
fetchProductBySerialNumber(serial); // OK

// ğŸ¤” ok, but many teams choose to disallow this sort of shadowing via linter rules.
const id = "12-34-56";
fetchProduct(id);
{
const id = 123456; // OK
fetchProductBySerialNumber(id); // OK
}
```

## Item 21: Understand Type Widening

- *windening*: to decide on a set of possible values from the single value that you specified
  - TSëŠ” ë„ˆë¬´ specificí•˜ì§€ë„ ë„ˆë¬´ flexibleí•˜ì§€ë„ ì•Šì€ ì¤‘ê°„ typeìœ¼ë¡œ inferenceí•¨(`let` ì‚¬ìš©ì‹œ)

  ```ts
  // {readonly x: 1} < {x: number} < {[key: string]: number} < object
  const v = {
    x: 1,
  };
  ```

- objectì˜ ê²½ìš° ê° elementì˜ typeì„ `let`ìœ¼ë¡œ í• ë‹¹í•  ê²ƒì²˜ëŸ¼ inferenceí•¨

### TSê°€ wideningí•œ typeì„ overridingí•˜ëŠ” ë²•

- explicit type annotation
- additional context(Item 26)
- `as const`: let TS infer the narrowest possible type for it without widening

```ts
// Type is { x: number; y: number; }
const v1 = {
  x: 1,
  y: 2,
}; 

// Type is { x: 1; y: number; }
const v2 = {
  x: 1 as const,
  y: 2,
}; 

// Type is { readonly x: 1; readonly y: 2; }
const v3 = {
  x: 1,
  y: 2,
} as const; 

const a1 = [1, 2, 3]; // Type is number[]
const a2 = [1, 2, 3] as const; // Type is readonly [1, 2, 3]
```

## Item 22: Understand Type Narrowing

## Item 23: Create Objects All at Once

## Item 24: Be Consistent in Your Use of Aliases

## Item 25: Use async Functions Instead of Callbacks for Asynchronous Code

## Item 26: Understand How Context Is Used in Type Inference

## Item 27: Use Functional Constructs and Libraries to Help Types Flow
