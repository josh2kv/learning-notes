# CHAPTER 3 Type Inference

> ğŸ“ *statically typedâ€ and â€œexplicitly typedâ€
>
>*statically typed*: a type checking system that occurs at compile-time
>*explicitly typed*: a programming language feature where the types of variables and expressions must be explicitly declared by the programmer.
> While these concepts are related, they are not the same thing. A language can be statically typed but not explicitly typed (e.g. C), or explicitly typed but not statically typed (e.g. Python). A language can also be both statically typed and explicitly typed (e.g. Java).

## Item 19: Avoid Cluttering Your Code with Inferable Types

- type annotationì´ ì“¸ë°ì—†ì´ ë§ìœ¼ë©´ refactorì‹œ ë¶ˆí¸

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

// ğŸ‘ bad
function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

// ğŸ‘ good
function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
```

- ì–´ë–¤ ì–¸ì–´ë“¤ì€ ì‚¬ìš©ì‹œì ì— parameterì˜ typeì„ ê²°ì •í•˜ê¸°ë„ í•˜ì§€ë§Œ TSì—ì„œ variableì˜ typeì€ ì²˜ìŒ ë§Œë“¤ì–´ì§ˆ ë•Œ ê²°ì •ë¨

### type annotationì´ ë¶ˆí•„ìš”í•œ ê²½ìš°(parameters)

- parameterì˜ default ê°’ì´ ì§€ì •ëœ ê²½ìš°
- ì–´ë–¤ functionì´ ì´ë¯¸ type annotationì„ ê°€ì§€ëŠ” libraryì— callbackìœ¼ë¡œ ë„˜ê²¨ì§€ëŠ” ê²½ìš°

```ts
// ğŸ‘ bad
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send('OK');
});

// ğŸ‘ good
app.get('/health', (request, response) => {
  response.send('OK');
});
```

### type annotationì´ í•„ìš”í•œ ê²½ìš°

#### object literalì„ ì‚¬ìš©í•  ë•Œ

- excess property checking ì‚¬ìš© ê°€ëŠ¥
- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const furby = {
    name: 'Furby',
    // ğŸ’¥ idì˜ typeì€ `string`
    id: 630509430963,
    price: 35,
  };
  logProduct(furby);
  // ~~~~~ Argument .. is not assignable to parameter of type 'Product'
  // Types of property 'id' are incompatible
  // Type 'number' is not assignable to type 'string'

  // ğŸ‘ good
  const furby: Product = {
    name: 'Furby',
    id: 630509430963,
    // ~~ Type 'number' is not assignable to type 'string'
    price: 35,
  };
  logProduct(furby);
  ```

#### a function's return type

- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string) {
    if (ticker in cache) {
      // ğŸ’¥ Promise.resolve(cache[ticker])ë¥¼ returní–ˆì–´ì•¼ í•¨
      return cache[ticker];
    }
    return fetch(`https://quotes.example.com/?q=${ticker}`)
      .then(response => response.json())
      .then(quote => {
        cache[ticker] = quote;
        return quote;
      });
  }
  getQuote('MSFT').then(considerBuying);
  // ~~~~ Property 'then' does not exist on type
  // 'number | Promise<any>'
  // Property 'then' does not exist on type 'number'

  // ğŸ‘ good
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string): Promise<number> {
    if (ticker in cache) {
      return cache[ticker];
      // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise<number>'
    }
    // ...
  }
  ```

- functionì„ ëª…í™•í•˜ê²Œ ì´í•´ì‹œì¼œì¤Œ
  - functionì„ êµ¬í˜„í•˜ê¸° ì „ì— inputê³¼ outputì„ ë¨¼ì € í™•ì‹¤íˆ í•˜ê³ (the function's contract, aka type signatureì„ ë¨¼ì € ì‘ì„±í•˜ê³ ) ì‹œì‘í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ(TDDì˜ ì •ì‹ )â­

> ğŸ“ test-driven development(TDD)
>
> : you write the tests that exercise a function before you implement it.

- named typeì„ ì‚¬ìš©í•˜ê²Œ í•´ì¤Œ

```ts
interface Vector2D { x: number; y: number; }
// ğŸ‘ bad
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y }; // type: { x: number; y: number; }
}
// ğŸ‘ good
function add(a: Vector2D, b: Vector2D): Vector2D {
  return { x: a.x + b.x, y: a.y + b.y }; // type: Vector2D
}
```

> ğŸ’¡ eslintì˜ `no-inferrable-types` ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ë¶ˆí•„ìš”í•œ type annotationì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ì¤Œ

## Item 20: Use Different Variables for Different Types

```ts
let id = "12-34-56";
fetchProduct(id);
id = 123456;
// ~~ '123456' is not assignable to type 'string'.
fetchProductBySerialNumber(id);
// ~~ Argument of type 'string' is not assignable to
// parameter of type 'number'

// ğŸ‘ bad
let id: string|number = "12-34-56";
fetchProduct(id);
id = 123456; 
fetchProductBySerialNumber(id); 

// ğŸ‘ good
const id = "12-34-56";
fetchProduct(id);
const serial = 123456; // OK
fetchProductBySerialNumber(serial); // OK

// ğŸ¤” ok, but many teams choose to disallow this sort of shadowing via linter rules.
const id = "12-34-56";
fetchProduct(id);
{
const id = 123456; // OK
fetchProductBySerialNumber(id); // OK
}
```

## Item 21: Understand Type Widening

- *windening*: to decide on a set of possible values from the single value that you specified
  - TSëŠ” ë„ˆë¬´ specificí•˜ì§€ë„ ë„ˆë¬´ flexibleí•˜ì§€ë„ ì•Šì€ ì¤‘ê°„ typeìœ¼ë¡œ inferenceí•¨(`let` ì‚¬ìš©ì‹œ)

  ```ts
  // {readonly x: 1} < {x: number} < {[key: string]: number} < object
  const v = {
    x: 1,
  };
  ```

- objectì˜ ê²½ìš° ê° elementì˜ typeì„ `let`ìœ¼ë¡œ í• ë‹¹í•  ê²ƒì²˜ëŸ¼ inferenceí•¨

### TSê°€ wideningí•œ typeì„ overridingí•˜ëŠ” ë²•

- explicit type annotation
- additional context(Item 26)
- `as const`: let TS infer the narrowest possible type for it without widening

```ts
// Type is { x: number; y: number; }
const v1 = {
  x: 1,
  y: 2,
}; 

// Type is { x: 1; y: number; }
const v2 = {
  x: 1 as const,
  y: 2,
}; 

// Type is { readonly x: 1; readonly y: 2; }
const v3 = {
  x: 1,
  y: 2,
} as const; 

const a1 = [1, 2, 3]; // Type is number[]
const a2 = [1, 2, 3] as const; // Type is readonly [1, 2, 3]
```

## Item 22: Understand Type Narrowing

### narrowing í•˜ëŠ” ë°©ë²•

- `if`
- `instanceof`

```ts
function contains(text: string, search: string|RegExp) {
  if (search instanceof RegExp) {
    search // Type is RegExp
    return !!search.exec(text);
  }
  search // Type is string
  return text.includes(search);
}
```

- property check: `in`

```ts
interface A { a: number }
interface B { b: number }
function pickAB(ab: A | B) {
  if ('a' in ab) {
    ab // Type is A
  } else {
    ab // Type is B
  }
  ab // Type is A | B
}
```

- built-in function: `Array.isArray`...
- tagged union(=discriminated union)

```ts
interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;
function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
    e // Type is DownloadEvent
    break;
    case 'upload':
    e; // Type is UploadEvent
    break;
  }
}
```

- user-defined type guard: `isSomething`ê³¼ ê°™ì´ booleanì„ returní•˜ëŠ” ì‚¬ìš©ìê°€ ì •ì˜í•œ function
  - `is` keywordì™€ ê°™ì´ ì‚¬ìš©í•˜ë©´ narrowing ê°€ëŠ¥
  - `is`: return typeì— `boolean` type ëŒ€ì‹  `A(argument) is B(type)`ë¼ê³  ë„£ì–´ì£¼ë©´, í•´ë‹¹ functionì´ trueë¥¼ returní•œë‹¤ë©´ Aê°€ B typeì„ì„ type checkerì— ì•Œë ¤ì¤Œ

```ts
function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // Type is HTMLInputElement
    return el.value;
  }
  el; // Type is HTMLElement
  return el.textContent;
}
```

```ts
// ğŸ‘ `Array.filter()`ê°€ typeì„ ê±¸ëŸ¬ì£¼ì§€ ëª»í•¨
const members = ['Janet', 'Michael'].map(
  who => jackson5.find(n => n === who)
).filter(who => who !== undefined); // Type is (string | undefined)[]

// ğŸ‘ user-defined type guard with `is`
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}
const members = ['Janet', 'Michael'].map(
  who => jackson5.find(n => n === who)
).filter(isDefined); // Type is string[]
```

> ğŸ’¡ ì™œ `Array.filter()`ì—ì„œ `undefined`ë¥¼ filteringí–ˆëŠ”ë° typeì— `undefined`ê°€ ë‚¨ëŠ”ê°€?
>
> In TypeScript, "control flow analysis" refers to the process of analyzing the flow of control in your code to determine the types of variables at different points in your program.
>For example, if you have an if statement that checks a condition and assigns a value to a variable, TypeScript will analyze the flow of control in your program to determine the possible types of the variable depending on whether the condition is true or false.
>In the case of the filter() method, TypeScript analyzes the flow of control in your program to determine that the method returns an array that is a subset of the original array, but TypeScript does not perform a deep analysis of the specific logic inside the callback function passed to the filter() method to determine whether undefined values are always filtered out.
>This means that TypeScript cannot guarantee that the resulting array after the filter() method will not contain undefined values, and therefore infers the type of the members array as (string | undefined)[].

### ì˜ëª» ì‚¬ìš©í•œ ì¼€ì´ìŠ¤

```ts
// âŒ: typeof nullì€ 'object'
const el = document.getElementById('foo'); // type is HTMLElement | null
if (typeof el === 'object') {
  el; // Type is HTMLElement | null
}

// âŒ: empty stringê³¼ 0ì€ falsy value
function foo(x?: number|string|null) {
  if (!x) {
    x; // Type is string | number | null | undefined
  }
}
```

## Item 23: Create Objects All at Once

### ì‘ì€ objectë“¤ì„ ì¡°í•©í•´ì„œ í° objectë¥¼ ë§Œë“¤ì–´ì•¼ ë˜ëŠ” ê²½ìš°

- *object spread operator* ì´ìš©

```ts
// ğŸ‘ bad
// variableì˜ valueëŠ” ë°”ë€” ìˆ˜ ìˆì–´ë„ ì¼ë°˜ì ìœ¼ë¡œ typeì€ ë°”ë€” ìˆ˜ ì—†ìŒ
const id = {name: 'Pythagoras'};
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name;
// ~~~~ Property 'name' does not exist on type '{}'

// ğŸ‘ good
const namedPoint = {...pt, ...id};
namedPoint.name; // OK, type is string
```

### ì¡°ê±´ë¶€ë¡œ propertyë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ì€ ê²½ìš°

- helper function ì´ìš©

```ts
declare let hasMiddle: boolean;
const firstLast = {first: 'Harry', last: 'Truman'};

// â“ ì±…ê³¼ ë‹¤ë¥´ê²Œ ì‹¤ì œë¡œ í•´ë³´ë‹ˆ ì—ëŸ¬ì•ˆë‚¨
// const president: {
//    middle?: string | undefined;
//    first: string;
//    last: string;
// }
const president = {...firstLast, ...(hasMiddle && {middle: 'S'} )};
president.middle
// ~~~~~~ Property 'middle' does not exist on type
// '{ first: string; last: string; }'

// ğŸ’¡ good
// const president: {
//     first: string;
//     last: string;
// } & Partial<{
//     middle: string;
// }>
function addOptional<T extends object, U extends object>(
  a: T, b: U | null
): T & Partial<U> {
  return {...a, ...b};
}
const president = addOptional(firstLast, hasMiddle ? {middle: 'S'} : null);
president.middle // OK, type is string | undefined
```

## Item 24: Be Consistent in Your Use of Aliases

### Alias

- *alias*: ê°’ì— ìƒˆë¡œìš´ ì´ë¦„ì„ ë¶€ì—¬í•œ ê²ƒ

```ts
const borough = {name: 'Brooklyn', location: [40.688, -73.979]};
const loc = borough.location; // loc is alias 
```

- aliasëŠ” complierë¥¼ ë§Œë“œëŠ” ì‚¬ëŒë“¤ì—ê²Œ ê³¨ì¹«ê±°ë¦¬
  - control flow analysisë¥¼ ì–´ë µê²Œ ë§Œë“¤ê¸° ë•Œë¬¸

### í•œë²ˆ aliasë¥¼ ë§Œë“¤ì—ˆìœ¼ë©´ ì´ì „ variableì€ ë‹¤ì‹œ ì“°ì§€ ë§ì

```ts
interface Coordinate {
  x: number;
  y: number;
}
interface BoundingBox {
  x: [number, number];
  y: [number, number];
}
interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}

// ğŸ‘ bad
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  // polygon.bbox: BoundingBox | undefined
  // box: BoundingBox | undefined
  if (polygon.bbox) {
    // polygon.bbox: BoundingBox
    // box: BoundingBox | undefined
    if (pt.x < box.x[0] || pt.x > box.x[1] ||
      // ~~~ ~~~ Object is possibly 'undefined'
      pt.y < box.y[1] || pt.y > box.y[1]) {
        // ~~~ ~~~ Object is possibly 'undefined'
        return false;
    }
  }
  // ...
}

// ğŸ‘ good
// ê°™ì€ ê°’ì„ ê°€ë¦¬í‚¤ëŠ”ë° ì´ë¦„ì´ ë‹¤ë¦„ bbox/box
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (box) {
    if (pt.x < box.x[0] || pt.x > box.x[1] ||
    pt.y < box.y[1] || pt.y > box.y[1]) { // OK
      return false;
  }
  }
  // ...
}

// ğŸ¤© better
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const {bbox} = polygon;
  if (bbox) {
    const {x, y} = bbox;
    if (pt.x < x[0] || pt.x > x[1] ||
    pt.y < x[0] || pt.y > y[1]) {
      return false;
    }
  }
  // ...
}
```

- ğŸ’¡ `Polygon`ì˜ `holes`ëŠ” ì—†ëŠ” ê²½ìš°ë„ ìˆì„ ìˆ˜ ìˆì§€ë§Œ ê·¸ ê²½ìš°ë¥¼ optionalë¡œ ì²˜ë¦¬í•˜ì—¬ `undefined`ë¥¼ ë§Œë“œëŠ” ê²ƒë³´ë‹¤ ë¹ˆ ë°°ì—´(`[]`)ì´ êµ¬ë©ì´ ì—†ì„ì„ ë‚˜íƒ€ë‚´ëŠ” ë” ì¢‹ì€ ë°©ë²•ì„

### aliasë¥¼ ë§Œë“¤ ë•ŒëŠ” destructuringì„ ì ê·¹ í™œìš©í•˜ì

- variable nameì˜ ì¼ê´€ì„±ì„ ì§€í‚¬ ìˆ˜ ìˆìŒ
- TSì˜ control flow analysisëŠ” local variableì—ëŠ” ê½¤ ì •í™•í•˜ì§€ë§Œ, propertyì—ëŠ” ë¹ˆì•½
  - `fn()`ì—ì„œ `polygon.bbox`ê°€ ì–´ë–»ê²Œ ë³€í˜•ë  ì§€ ëª¨ë¥´ê¸° ë•Œë¬¸ì— typeì„ `BoundingBox | undefined`ë¡œ ë˜ëŒë¦¬ëŠ” ê²ƒì´ ì›ë˜ ë” ì•ˆì „í•¨
  - í•˜ì§€ë§Œ ê·¸ëŸ¬ë©´ `fn()`ì„ callí•  ë•Œë§ˆë‹¤ property checkë¥¼ ë°˜ë³µí•´ì•¼í•  ìˆ˜ë„ ìˆìŒ
  - ë”°ë¼ì„œ TSëŠ” typeì„ ë˜ëŒë¦¬ì§€ ì•ŠëŠ” ìª½ì„ ì„ íƒí•¨
  - local variable(`bbox`)ë¡œ destructuringí•˜ë©´ `polygon.box`ì˜ typeì€ ìœ ì§€í•  ìˆ˜ ìˆì§€ë§Œ ë‘˜ì˜ ê°’ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ

  ```ts
  function fn(p: Polygon) {
    delete p.bbox
  }
  
  function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
    if (polygon.bbox) {
      polygon.bbox // Type is BoundingBox
      fn(polygon);
      polygon.bbox // Type is still BoundingBox
    }
  }
  ```

## Item 25: Use async Functions Instead of Callbacks for Asynchronous Code

### callbackë³´ë‹¨ `Promise`ë¥¼ ì‚¬ìš©í•˜ì

- type inferenceê°€ ì˜ ë¨
- `fetch`ì˜ returnê°’ì¸ `Promise`ë¥¼ `Response`ë¼ëŠ” built-in interfaceë¡œ inference
- `Promise.all`

```ts
// ğŸ‘ requests in parallel with callback
function fetchPagesCB() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () => {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) => {
    fetchURL(url, r => {
      responses[i] = url;
      numDone++;
      if (numDone === urls.length) done();
    });
  });
}

// ğŸ‘ async/await version
async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([
    fetch(url1), fetch(url2), fetch(url3)
  ]);
  // ...
}
```

- `Promise.race`
  - `fetchWithTimeout`ì˜ return typeì€ `Promise<Response>`ë¡œ inference
    - ì›ë˜ `Promise<Response | never>`ì´ì§€ë§Œ union typeì— `never`ì€ ì•„ë¬´ëŸ° ì˜í–¥x

```ts
function timeout(millis: number): Promise<never> {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject('timeout'), millis);
  });
}

async function fetchWithTimeout(url: string, ms: number) {
  return Promise.race([fetch(url), timeout(ms)]);
}
```

> `Response`
>
> : The `Response` interface of the Fetch API represents the response to a request.
> You can create a new `Response` object using the `Response()` constructor, but you are more likely to encounter a `Response` object being returned as the result of another API operationâ€”for example, a service worker `FetchEvent.respondWith`, or a simple `fetch()`.
> <https://developer.mozilla.org/en-US/docs/Web/API/Response>

> no-op
>
> : a shorthand term for "no operation".
> In programming, a no-op refers to a statement or command that does nothing when executed.
>

### ì–´ì©” ìˆ˜ ì—†ëŠ” ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´ raw `Promise`ë§ê³  `async/await`ë¥¼ ì“°ì

- `async` functionì€ `await`ë¥¼ ì•ˆ ë¶™ì—¬ë„ ì–¸ì œë‚˜ `Promise`ë¥¼ return
  - â­ `Promise`ë¥¼ returní•˜ê³  ì‹¶ë‹¤ë©´ `async`ë¥¼ ë¶™ì´ì

```ts
// function getNumber(): Promise<number>
async function getNumber() {
  return 42;
}

// same
const getNumber = () => Promise.resolve(42);
```

- â­ functionì€ synchronousë‚˜ asynchronousë¡œ ì¼ê´€ë˜ê²Œ í•˜ë‚˜ë¡œë§Œ ì‚¬ìš©í•´ì•¼ í•¨
  - `async/await`ëŠ” ê·¸ëŸ° ì‹¤ìˆ˜ë¥¼ ì¤„ì—¬ì¤Œ
- `async` functionì—ì„œ `Promise`ë¥¼ returní•œë‹¤ê³  í•´ì„œ ê·¸ê±¸ ë‹¤ì‹œ `Promise`ë¡œ ê°ì‹¸ì§€ ì•ŠìŒ
  - ì¦‰ return typeì€ `Promise<Promise<T>>`ì´ ì•„ë‹Œ `Promise<T>`

```ts
// Function getJSON(url: string): Promise<any>
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json(); // Type is Promise<any>
  return jsonPromise;
}
```

## Item 26: Understand How Context Is Used in Type Inference

### TSëŠ” type inferenceë¥¼ í•  ë•Œ í•´ë‹¹ variableì˜ ìƒì„± ì‹œì ì˜ valueë§Œ ê³ ë ¤í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ ìƒì„± ë‹¹ì‹œ contextë¥¼ ë°˜ì˜í•œë‹¤

- â­ type inferenceëŠ” variableì˜ ìƒì„±ì‹œì ì— ë°œìƒí•˜ê³  ë‹¹ì‹œ contextë¥¼ ê³ ë ¤í•¨
  - 1ï¸âƒ£ string literalë¡œ ë„£ì„ ë•ŒëŠ” ê·¸ valueê°€ ìƒì„±ë˜ë©´ì„œ í˜„ì¬ ê·¸ valueê°€ function callì˜ argumentë¡œ ë“¤ê°„ë‹¤ëŠ” contextë¥¼ TSê°€ ì•Œ ìˆ˜ ìˆìŒ
  - ë”°ë¼ì„œ í•´ë‹¹ function's parameterì˜ typeì„ ê³ ë ¤í•˜ì—¬(ì‚¬ìš©ìì˜ ì˜ë„ë¥¼ ê³ ë ¤í•˜ì—¬)  string literalì˜ typeì„ ê·¸ëƒ¥ `string`ì´ ì•„ë‹Œ ê·¸ value('JavaScript')ë¡œ inferenceí•¨
  - ë°˜ë©´ 2ï¸âƒ£ variable(`language`)ì— ë‹´ì•„ ë„£ì„ ë•ŒëŠ” ê·¸ variableì´ ìƒì„±ë  ë‹¹ì‹œ ì°¸ê³ í•  contextê°€ ì—†ìœ¼ë¯€ë¡œ ê·¸ëƒ¥ í‰ì†Œì²˜ëŸ¼ `string`ìœ¼ë¡œ inferenceí•´ë²„ë¦¼

```ts
type Language = 'JavaScript' | 'TypeScript' | 'Python';

function setLanguage(language: Language) { /* ... */ }

// 1ï¸âƒ£
setLanguage('JavaScript'); // OK

// 2ï¸âƒ£
let language = 'JavaScript';
setLanguage(language);
// ~~~~~~~~ Argument of type 'string' is not assignable
// to parameter of type 'Language'
```

### valueì™€ ê·¸ valueê°€ ì‚¬ìš©ë˜ëŠ” contextë¥¼ ë¶„ë¦¬í•˜ë©´ ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŒ

#### Tuple Types

- í•´ê²°ë°©ë²•: type declaration ë˜ëŠ” `as const`

```ts
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) { /* ... */ }

panTo([10, 20]); // OK

const loc = [10, 20];
// ğŸ‘ 
panTo(loc);
// ~~~ Argument of type 'number[]' is not assignable to
// parameter of type '[number, number]'

// ğŸ‘
const loc: [number, number] = [10, 20];
panTo(loc); // OK


// ğŸ‘
function panTo(where: readonly [number, number]) { /* ... */ }
const loc = [10, 20] as const;
panTo(loc);
```

- `as const`ë¡œ ë¬¸ì œí•´ê²°ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œì 
  - definitionì—ì„œ ì‹¤ìˆ˜ë¥¼ í•˜ë©´ type errorê°€ ìƒì„±ì¥ì†Œ(definition)ê°€ ì•„ë‹Œ ì‚¬ìš©ì¥ì†Œ(function call)ì—ì„œ ë°œìƒí•¨

```ts
const loc = [10, 20, 30] as const; // error is really here.
panTo(loc);
// ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to
// parameter of type 'readonly [number, number]'
// Types of property 'length' are incompatible
// Type '3' is not assignable to type '2'
```

#### Objects

- í•´ê²°ë°©ë²•: type declaration ë˜ëŠ” `as const`

```ts
type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'TypeScript', organization: 'Microsoft' }); // OK

const ts = {
  language: 'TypeScript',
  organization: 'Microsoft',
};
complain(ts);
// ~~ Argument of type '{ language: string; organization: string; }'
// is not assignable to parameter of type 'GovernedLanguage'
// Types of property 'language' are incompatible
// Type 'string' is not assignable to type 'Language'
```

#### Callbacks

- í—¤ê²°ë°©ë²•: type annotations to the parameters ë˜ëŠ” type declaration to the function

```ts
function callWithRandomNumbers(fn: (n1: number, n2: number) => void) {
  fn(Math.random(), Math.random());
}

callWithRandomNumbers((a, b) => {
  a; // Type is number
  b; // Type is number
  console.log(a + b);
});

const fn = (a, b) => {
  // ~ Parameter 'a' implicitly has an 'any' type
  // ~ Parameter 'b' implicitly has an 'any' type
  console.log(a + b);
}
callWithRandomNumbers(fn);
```

## Item 27: Use Functional Constructs and Libraries to Help Types Flow

### ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ type declarationì€ ì–´ë–¤ typeì´ ì—¬ëŸ¬ êµ¬ì„±ìš”ì†Œ(constructs)ë“¤ì„ ê±°ì¹œ ë’¤ì—ë„ typeì„ ì •í™•íˆ ìœ ì§€í•˜ê²Œ í•´ì¤€ë‹¤

- `rowsA`ê³¼ `rowsB`ëŠ” `row`ì˜ typeì„ `{[column: string]: string}` ë˜ëŠ” `Record<string, string>`ìœ¼ë¡œ ì§ì ‘ annotationí•´ì¤˜ì•¼ í•¨.
- `rowsC`ì˜ `Dictionary<string>` typeì€  `{[column: string]: string}` ë˜ëŠ” `Record<string, string>`ì™€ ê°™ìŒ

```ts
const csvData = 'head1,head2,head3\na1,a2,a3\nb1,b2,b3';
const rawRows = csvData.split('\n');
const headers = rawRows[0].split(',');

// ğŸ‘ with plain JS
const rowsA = rawRows.slice(1).map(rowStr => {
  // ì—¬ê¸°ì„œ `row`ì˜ typeì€ `{}ë¡œ ì •í•´ì§
  const row = {};
  rowStr.split(',').forEach((val, j) =>  {
    row[headers[j]] = val;
    // ~~~~~~~~~~~~~~~ No index signature with a parameter of
    // type 'string' was found on type '{}'
  });
  return row;
});

// ğŸ˜• with some functional JS
const rowsB = rawRows
  .slice(1)
  .map(rowStr =>
    rowStr
      .split(',')
      // ì´ˆê¸°ê°’ì—ì„œ `row`ì˜ typeì´ `{}`ë¡œ ì •í•´ì§
      .reduce((row, val, i) => ((row[headers[i]] = val), row), {})
      // ~~~~~~~~~~~~~~~ No index signature with a parameter of
      // type 'string' was found on type '{}'
  );

// ğŸ‘ with Lodash
const rowsC = rawRows
  .slice(1)
  .map((rowStr) => _.zipObject(headers, rowStr.split(",")));
```

### built-in functional constructsë„ type ìœ ì§€ì— ë„ì›€ì´ ëœë‹¤

- objectë¼ë„ `let` ëŒ€ì‹  `const`ë¥¼ ì‚¬ìš©í•˜ë©´ ë‚˜ì¤‘ì— í•´ë‹¹ variableì´ mutateë˜ë©´ TS errorë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìŒ
  - "Cannot assign to 'allPlayers' because it is a constant."

```ts
interface BasketballPlayer {
  name: string;
  team: string;
  salary: number;
}

declare const rosters: { [team: string]: BasketballPlayer[] };

// ğŸ‘ `allPlayers`ì— `BasketballPlayer[]` type annotation í•„ìš”
let allPlayers = [];
// ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'
// in some locations where its type cannot be determined
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);
  // ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type
}

// ğŸ‘ with built-in functional method (`T[][]` => `T[]`)
const allPlayers = Object.values(rosters).flat();
```

### ë°ì´í„°ê°€ ë³µì¡í•´ì§ˆìˆ˜ë¡ ë” í•„ìš”í•˜ë‹¤

- ì½”ë“œê°€ ê°„ê²°í•´ì§ˆë¿ë§Œ ì•„ë‹ˆë¼ type annotationë„ ë¶ˆí•„ìš”
  - `_.a(_.b(_.c(v)))` ëŒ€ì‹  `_(v).a().b().c().value()`
  - ì´ì²˜ëŸ¼ chainingí•˜ë©´ ìì—°ìŠ¤ëŸ¬ìš´ ìˆœì„œë¡œ(ì¢Œì—ì„œ ìš°ë¡œ ë˜ëŠ” ìœ„ì—ì„œ ì•„ë˜ë¡œ) methodë“¤ì´ ì“°ì—¬ì§€ë¯€ë¡œ ê°€ë…ì„±ì´ ì¢‹ì•„ì§

```ts
// íŒ€ë³„ ìµœê³  ì—°ë´‰ì„ ìˆ˜ë§Œ ëª¨ìœ¼ê¸°

// ğŸ‘ `teamToPlayers`ì— `{ [team: string]: BasketballPlayer[] }` type annotation í•„ìš”
const teamToPlayers = {};

for (const player of allPlayers) {
  const { team } = player;
  teamToPlayers[team] = teamToPlayers[team] || [];
  teamToPlayers[team].push(player);
}

for (const players of Object.values(teamToPlayers)) {
  players.sort((a, b) => b.salary - a.salary);
}

const bestPaid = Object.values(teamToPlayers).map((players) => players[0]);
bestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);

// ğŸ‘ with Lodash
// but, non-null assertionì„ í•˜ë‚˜ ì‚¬ìš©í–ˆìŒ
const bestPaid = _(allPlayers)
  .groupBy((player) => player.team)
  .mapValues((players) => _.maxBy(players, (p) => p.salary)!)
  .values()
  .sortBy((p) => -p.salary)
  .value(); // Type is BasketballPlayer[]
```

- ì¼ë¶€ íŠ¹ì´í•œ ì¶•ì•½í‘œí˜„ë“¤ë„ TSëŠ” ì •í™•íˆ ëª¨ë¸ë§í•¨
  - `_.map()`: callback ëŒ€ì‹  element objectì˜ property keyë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŒ

```ts
const namesA = allPlayers.map(player => player.name) // Type is string[]
const namesB = _.map(allPlayers, player => player.name) // Type is string[]
const namesC = _.map(allPlayers, 'name'); // Type is string[]

const salaries = _.map(allPlayers, 'salary'); // Type is number[]
const teams = _.map(allPlayers, 'team'); // Type is string[]
const mix = _.map(allPlayers, Math.random() < 0.5 ? 'name' : 'salary');
// Type is (string | number)[]
```

- ì• ì´ˆì— TSì˜ íƒ„ìƒì€ libraryì˜ ë™ì‘ì„ ì •í™•í•˜ê²Œ ëª¨ë¸ë§í•˜ë ¤ëŠ” ì‹œë„ì—ì„œ ì‹œì‘ë˜ì—ˆìŒ

> ğŸ“ Constructs
>
> : a specific language feature or syntax that allows developers to express a particular concept or solve a specific problem.
> Constructs can range from basic ones like variables, loops, and conditionals to more advanced ones like closures, generators, and classes. In essence, constructs provide a way for developers to structure and organize their code to achieve a desired outcome.
