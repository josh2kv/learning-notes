# 3. Type Inference

> ğŸ“ *statically typedâ€ and â€œexplicitly typedâ€
>
>*statically typed*: a type checking system that occurs at compile-time
>*explicitly typed*: a programming language feature where the types of variables and expressions must be explicitly declared by the programmer.
> While these concepts are related, they are not the same thing. A language can be statically typed but not explicitly typed (e.g. C), or explicitly typed but not statically typed (e.g. Python). A language can also be both statically typed and explicitly typed (e.g. Java).

## Item 19: Avoid Cluttering Your Code with Inferable Types

- type annotationì´ ì“¸ë°ì—†ì´ ë§ìœ¼ë©´ refactorì‹œ ë¶ˆí¸

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

// ğŸ‘ bad
function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

// ğŸ‘ good
function logProduct(product: Product) {
  const {id, name, price} = product;
  console.log(id, name, price);
}
```

- ì–´ë–¤ ì–¸ì–´ë“¤ì€ ì‚¬ìš©ì‹œì ì— parameterì˜ typeì„ ê²°ì •í•˜ê¸°ë„ í•˜ì§€ë§Œ TSì—ì„œ variableì˜ typeì€ ì²˜ìŒ ë§Œë“¤ì–´ì§ˆ ë•Œ ê²°ì •ë¨

### type annotationì´ ë¶ˆí•„ìš”í•œ ê²½ìš°(parameters)

- parameterì˜ default ê°’ì´ ì§€ì •ëœ ê²½ìš°
- ì–´ë–¤ functionì´ ì´ë¯¸ type annotationì„ ê°€ì§€ëŠ” libraryì— callbackìœ¼ë¡œ ë„˜ê²¨ì§€ëŠ” ê²½ìš°

```ts
// ğŸ‘ bad
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send('OK');
});

// ğŸ‘ good
app.get('/health', (request, response) => {
  response.send('OK');
});
```

### type annotationì´ í•„ìš”í•œ ê²½ìš°

#### object literalì„ ì‚¬ìš©í•  ë•Œ

- excess property checking ì‚¬ìš© ê°€ëŠ¥
- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const furby = {
    name: 'Furby',
    // ğŸ’¥ idì˜ typeì€ `string`
    id: 630509430963,
    price: 35,
  };
  logProduct(furby);
  // ~~~~~ Argument .. is not assignable to parameter of type 'Product'
  // Types of property 'id' are incompatible
  // Type 'number' is not assignable to type 'string'

  // ğŸ‘ good
  const furby: Product = {
    name: 'Furby',
    id: 630509430963,
    // ~~ Type 'number' is not assignable to type 'string'
    price: 35,
  };
  logProduct(furby);
  ```

#### a function's return type

- ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì—ì„œ type errorë¥¼ ë°œìƒì‹œì¼œì¤Œ(ì‚¬ìš©ë˜ëŠ” ìœ„ì¹˜ê°€ ì•„ë‹ˆë¼ ì •ì˜í•œ ìœ„ì¹˜ì—ì„œ)

  ```ts
  // ğŸ‘ bad
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string) {
    if (ticker in cache) {
      // ğŸ’¥ Promise.resolve(cache[ticker])ë¥¼ returní–ˆì–´ì•¼ í•¨
      return cache[ticker];
    }
    return fetch(`https://quotes.example.com/?q=${ticker}`)
      .then(response => response.json())
      .then(quote => {
        cache[ticker] = quote;
        return quote;
      });
  }
  getQuote('MSFT').then(considerBuying);
  // ~~~~ Property 'then' does not exist on type
  // 'number | Promise<any>'
  // Property 'then' does not exist on type 'number'

  // ğŸ‘ good
  const cache: {[ticker: string]: number} = {};
  function getQuote(ticker: string): Promise<number> {
    if (ticker in cache) {
      return cache[ticker];
      // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise<number>'
    }
    // ...
  }
  ```

- functionì„ ëª…í™•í•˜ê²Œ ì´í•´ì‹œì¼œì¤Œ
  - functionì„ êµ¬í˜„í•˜ê¸° ì „ì— inputê³¼ outputì„ ë¨¼ì € í™•ì‹¤íˆ í•˜ê³ (the function's contract, aka type signatureì„ ë¨¼ì € ì‘ì„±í•˜ê³ ) ì‹œì‘í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ(TDDì˜ ì •ì‹ )â­

> ğŸ“ test-driven development(TDD)
>
> : you write the tests that exercise a function before you implement it.

- named typeì„ ì‚¬ìš©í•˜ê²Œ í•´ì¤Œ

```ts
interface Vector2D { x: number; y: number; }
// ğŸ‘ bad
function add(a: Vector2D, b: Vector2D) {
  return { x: a.x + b.x, y: a.y + b.y }; // type: { x: number; y: number; }
}
// ğŸ‘ good
function add(a: Vector2D, b: Vector2D): Vector2D {
  return { x: a.x + b.x, y: a.y + b.y }; // type: Vector2D
}
```

> ğŸ’¡ eslintì˜ `no-inferrable-types` ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ ë¶ˆí•„ìš”í•œ type annotationì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ì¤Œ

## Item 20: Use Different Variables for Different Types

```ts
let id = "12-34-56";
fetchProduct(id);
id = 123456;
// ~~ '123456' is not assignable to type 'string'.
fetchProductBySerialNumber(id);
// ~~ Argument of type 'string' is not assignable to
// parameter of type 'number'

// ğŸ‘ bad
let id: string|number = "12-34-56";
fetchProduct(id);
id = 123456; 
fetchProductBySerialNumber(id); 

// ğŸ‘ good
const id = "12-34-56";
fetchProduct(id);
const serial = 123456; // OK
fetchProductBySerialNumber(serial); // OK

// ğŸ¤” ok, but many teams choose to disallow this sort of shadowing via linter rules.
const id = "12-34-56";
fetchProduct(id);
{
const id = 123456; // OK
fetchProductBySerialNumber(id); // OK
}
```

## Item 21: Understand Type Widening

- *windening*: to decide on a set of possible values from the single value that you specified
  - TSëŠ” ë„ˆë¬´ specificí•˜ì§€ë„ ë„ˆë¬´ flexibleí•˜ì§€ë„ ì•Šì€ ì¤‘ê°„ typeìœ¼ë¡œ inferenceí•¨(`let` ì‚¬ìš©ì‹œ)

  ```ts
  // {readonly x: 1} < {x: number} < {[key: string]: number} < object
  const v = {
    x: 1,
  };
  ```

- objectì˜ ê²½ìš° ê° elementì˜ typeì„ `let`ìœ¼ë¡œ í• ë‹¹í•  ê²ƒì²˜ëŸ¼ inferenceí•¨

### TSê°€ wideningí•œ typeì„ overridingí•˜ëŠ” ë²•

- explicit type annotation
- additional context(Item 26)
- `as const`: let TS infer the narrowest possible type for it without widening

```ts
// Type is { x: number; y: number; }
const v1 = {
  x: 1,
  y: 2,
}; 

// Type is { x: 1; y: number; }
const v2 = {
  x: 1 as const,
  y: 2,
}; 

// Type is { readonly x: 1; readonly y: 2; }
const v3 = {
  x: 1,
  y: 2,
} as const; 

const a1 = [1, 2, 3]; // Type is number[]
const a2 = [1, 2, 3] as const; // Type is readonly [1, 2, 3]
```

## Item 22: Understand Type Narrowing

### narrowing í•˜ëŠ” ë°©ë²•

- `if`
- `instanceof`

```ts
function contains(text: string, search: string|RegExp) {
  if (search instanceof RegExp) {
    search // Type is RegExp
    return !!search.exec(text);
  }
  search // Type is string
  return text.includes(search);
}
```

- property check: `in`

```ts
interface A { a: number }
interface B { b: number }
function pickAB(ab: A | B) {
  if ('a' in ab) {
    ab // Type is A
  } else {
    ab // Type is B
  }
  ab // Type is A | B
}
```

- built-in function: `Array.isArray`...
- tagged union(=discriminated union)

```ts
interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;
function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
    e // Type is DownloadEvent
    break;
    case 'upload':
    e; // Type is UploadEvent
    break;
  }
}
```

- user-defined type guard: `isSomething`ê³¼ ê°™ì´ booleanì„ returní•˜ëŠ” ì‚¬ìš©ìê°€ ì •ì˜í•œ function
  - `is` keywordì™€ ê°™ì´ ì‚¬ìš©í•˜ë©´ narrowing ê°€ëŠ¥
  - `is`: return typeì— `boolean` type ëŒ€ì‹  `A(argument) is B(type)`ë¼ê³  ë„£ì–´ì£¼ë©´, í•´ë‹¹ functionì´ trueë¥¼ returní•œë‹¤ë©´ Aê°€ B typeì„ì„ type checkerì— ì•Œë ¤ì¤Œ

```ts
function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // Type is HTMLInputElement
    return el.value;
  }
  el; // Type is HTMLElement
  return el.textContent;
}
```

```ts
// ğŸ‘ `Array.filter()`ê°€ typeì„ ê±¸ëŸ¬ì£¼ì§€ ëª»í•¨
const members = ['Janet', 'Michael'].map(
  who => jackson5.find(n => n === who)
).filter(who => who !== undefined); // Type is (string | undefined)[]

// ğŸ‘ user-defined type guard with `is`
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}
const members = ['Janet', 'Michael'].map(
  who => jackson5.find(n => n === who)
).filter(isDefined); // Type is string[]
```

> ğŸ’¡ ì™œ `Array.filter()`ì—ì„œ `undefined`ë¥¼ filteringí–ˆëŠ”ë° typeì— `undefined`ê°€ ë‚¨ëŠ”ê°€?
>
> In TypeScript, "control flow analysis" refers to the process of analyzing the flow of control in your code to determine the types of variables at different points in your program.
>For example, if you have an if statement that checks a condition and assigns a value to a variable, TypeScript will analyze the flow of control in your program to determine the possible types of the variable depending on whether the condition is true or false.
>In the case of the filter() method, TypeScript analyzes the flow of control in your program to determine that the method returns an array that is a subset of the original array, but TypeScript does not perform a deep analysis of the specific logic inside the callback function passed to the filter() method to determine whether undefined values are always filtered out.
>This means that TypeScript cannot guarantee that the resulting array after the filter() method will not contain undefined values, and therefore infers the type of the members array as (string | undefined)[].

### ì˜ëª» ì‚¬ìš©í•œ ì¼€ì´ìŠ¤

```ts
// âŒ: typeof nullì€ 'object'
const el = document.getElementById('foo'); // type is HTMLElement | null
if (typeof el === 'object') {
  el; // Type is HTMLElement | null
}

// âŒ: empty stringê³¼ 0ì€ falsy value
function foo(x?: number|string|null) {
  if (!x) {
    x; // Type is string | number | null | undefined
  }
}
```

## Item 23: Create Objects All at Once

### ì‘ì€ objectë“¤ì„ ì¡°í•©í•´ì„œ í° objectë¥¼ ë§Œë“¤ì–´ì•¼ ë˜ëŠ” ê²½ìš°

- *object spread operator* ì´ìš©

```ts
// ğŸ‘ bad
// variableì˜ valueëŠ” ë°”ë€” ìˆ˜ ìˆì–´ë„ ì¼ë°˜ì ìœ¼ë¡œ typeì€ ë°”ë€” ìˆ˜ ì—†ìŒ
const id = {name: 'Pythagoras'};
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name;
// ~~~~ Property 'name' does not exist on type '{}'

// ğŸ‘ good
const namedPoint = {...pt, ...id};
namedPoint.name; // OK, type is string
```

### ì¡°ê±´ë¶€ë¡œ propertyë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ì€ ê²½ìš°

- helper function ì´ìš©

```ts
declare let hasMiddle: boolean;
const firstLast = {first: 'Harry', last: 'Truman'};

// â“ ì±…ê³¼ ë‹¤ë¥´ê²Œ ì‹¤ì œë¡œ í•´ë³´ë‹ˆ ì—ëŸ¬ì•ˆë‚¨
// const president: {
//    middle?: string | undefined;
//    first: string;
//    last: string;
// }
const president = {...firstLast, ...(hasMiddle && {middle: 'S'} )};
president.middle
// ~~~~~~ Property 'middle' does not exist on type
// '{ first: string; last: string; }'

// ğŸ’¡ good
// const president: {
//     first: string;
//     last: string;
// } & Partial<{
//     middle: string;
// }>
function addOptional<T extends object, U extends object>(
  a: T, b: U | null
): T & Partial<U> {
  return {...a, ...b};
}
const president = addOptional(firstLast, hasMiddle ? {middle: 'S'} : null);
president.middle // OK, type is string | undefined
```

## Item 24: Be Consistent in Your Use of Aliases

## Item 25: Use async Functions Instead of Callbacks for Asynchronous Code

## Item 26: Understand How Context Is Used in Type Inference

## Item 27: Use Functional Constructs and Libraries to Help Types Flow
