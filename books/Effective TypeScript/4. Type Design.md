# CHAPTER 4 Type Design
>
> Show me your flowcharts and conceal your tables, and I shall continue to be mystified.
> Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.
> —Fred Brooks, *The Mythical Man Month*
> 플로우차트보다 데이터(또는 type)를 직접 보는 것이 이해하기 쉽다

- 이 챕터에서 소개하는 내용들은 TS에 한정된 것이 아니라 프로그래밍 전반에 적용됨

## Item 28: Prefer Types That Always Represent Valid States

### valid state와 invalid state를 둘다 담는 type는 복잡하고 에러가 발생하기 쉽다

- 애초에 state 설계를 잘못하면 거기서 파생되는 function들을 잘 만들기 힘듬
- 아래 코드의 문제점
  - 너무 적은 정보: 어떤 request가 실패했는지, 어떤 request가 로딩중인지 등이 없음
  - 너무 많은 정보: 충돌할 수 있는 정보들을 담고 있음(`isLoading`, `error`)
    - 로딩 중 error가 발생하면 `isLoading`은 `false`가 되고 `error`만 `true`여야 하는데 의도치 않게 둘다 `true`가 되는 경우가 생길 수도 있음

```ts
// 👎 bad
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}

// 😕 `isLoading`과 `error`가 모두 값이 있다면 어찌해야 하나?
function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }

  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}


// 😕 error처리시 `state.isLoading`을 `false`로 돌리는 것을 빼먹었음
//    error처리시 `state.error`를 다시 비워야 함
//    loading 중에 사용자가 다른 페이지로 이동한다면?
async function changePage(state: State, newPage: string) {
  state.isLoading = true;

  try {
    const response = await fetch(getUrlForPage(newPage));

    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }

    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = "" + e;
  }
}
```

- tagged union(discriminated union)을 활용
  - request(page)별로 state를 따로 관리함
  - request별로 "pending", "error" 또는 "ok" 중 하나의 state만 가질 수 있음

```ts
// 👍 good
interface RequestPending {
  state: "pending";
}

interface RequestError {
  state: "error";
  error: string;
}

interface RequestSuccess {
  state: "ok";
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}

// 😊 현재 page가 어딘지 명확함
//    동시에 request가 여러개 생겨도 겹치지 않고 하나만 보여줄 수 있음
function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `Loading ${currentPage}...`;
    case "error":
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case "ok":
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}
async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: "ok", pageText };
  } catch (e) {
    state.requests[newPage] = { state: "error", error: "" + e };
  }
}
```

- Airbus 330 비행기 사고 사례

```ts
👎 stick별로 state를 분리하면 최종 angle을 결정짓는 다른 무언가 필요하고 거기서 angle이 잘못 결정될 위험이 있음 
interface CockpitControls {
  /** (pilot) Angle of the left side stick in degrees, 0 = neutral, + = forward */
  leftSideStick: number;
  /** (copilot) Angle of the right side stick in degrees, 0 = neutral, + = forward */
  rightSideStick: number;
}

👍 애초에 stick별로 state를 분리하지 않으면 angle이 잘못될 위험이 없음
interface CockpitControls {
  /** Angle of the stick in degrees, 0 = neutral, + = forward */
  stickAngle: number;
}
```
