# CHAPTER 4 Type Design
>
> Show me your flowcharts and conceal your tables, and I shall continue to be mystified.
> Show me your tables, and I wonâ€™t usually need your flowcharts; theyâ€™ll be obvious.
> â€”Fred Brooks, *The Mythical Man Month*
> í”Œë¡œìš°ì°¨íŠ¸ë³´ë‹¤ ë°ì´í„°(ë˜ëŠ” type)ë¥¼ ì§ì ‘ ë³´ëŠ” ê²ƒì´ ì´í•´í•˜ê¸° ì‰½ë‹¤

- ì´ ì±•í„°ì—ì„œ ì†Œê°œí•˜ëŠ” ë‚´ìš©ë“¤ì€ TSì— í•œì •ëœ ê²ƒì´ ì•„ë‹ˆë¼ í”„ë¡œê·¸ë˜ë° ì „ë°˜ì— ì ìš©ë¨

## Item 28: Prefer Types That Always Represent Valid States

### valid stateì™€ invalid stateë¥¼ ë‘˜ë‹¤ ë‹´ëŠ” typeëŠ” ë³µì¡í•˜ê³  ì—ëŸ¬ê°€ ë°œìƒí•˜ê¸° ì‰½ë‹¤

- ì• ì´ˆì— state ì„¤ê³„ë¥¼ ì˜ëª»í•˜ë©´ ê±°ê¸°ì„œ íŒŒìƒë˜ëŠ” functionë“¤ì„ ì˜ ë§Œë“¤ê¸° í˜ë“¬
- ì•„ë˜ ì½”ë“œì˜ ë¬¸ì œì 
  - ë„ˆë¬´ ì ì€ ì •ë³´: ì–´ë–¤ requestê°€ ì‹¤íŒ¨í–ˆëŠ”ì§€, ì–´ë–¤ requestê°€ ë¡œë”©ì¤‘ì¸ì§€ ë“±ì´ ì—†ìŒ
  - ë„ˆë¬´ ë§ì€ ì •ë³´: ì¶©ëŒí•  ìˆ˜ ìˆëŠ” ì •ë³´ë“¤ì„ ë‹´ê³  ìˆìŒ(`isLoading`, `error`)
    - ë¡œë”© ì¤‘ errorê°€ ë°œìƒí•˜ë©´ `isLoading`ì€ `false`ê°€ ë˜ê³  `error`ë§Œ `true`ì—¬ì•¼ í•˜ëŠ”ë° ì˜ë„ì¹˜ ì•Šê²Œ ë‘˜ë‹¤ `true`ê°€ ë˜ëŠ” ê²½ìš°ê°€ ìƒê¸¸ ìˆ˜ë„ ìˆìŒ

```ts
// ğŸ‘ bad
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}

// ğŸ˜• `isLoading`ê³¼ `error`ê°€ ëª¨ë‘ ê°’ì´ ìˆë‹¤ë©´ ì–´ì°Œí•´ì•¼ í•˜ë‚˜?
function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }

  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}


// ğŸ˜• errorì²˜ë¦¬ì‹œ `state.isLoading`ì„ `false`ë¡œ ëŒë¦¬ëŠ” ê²ƒì„ ë¹¼ë¨¹ì—ˆìŒ
//    errorì²˜ë¦¬ì‹œ `state.error`ë¥¼ ë‹¤ì‹œ ë¹„ì›Œì•¼ í•¨
//    loading ì¤‘ì— ì‚¬ìš©ìê°€ ë‹¤ë¥¸ í˜ì´ì§€ë¡œ ì´ë™í•œë‹¤ë©´?
async function changePage(state: State, newPage: string) {
  state.isLoading = true;

  try {
    const response = await fetch(getUrlForPage(newPage));

    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }

    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = "" + e;
  }
}
```

- tagged union(discriminated union)ì„ í™œìš©
  - request(page)ë³„ë¡œ stateë¥¼ ë”°ë¡œ ê´€ë¦¬í•¨
  - requestë³„ë¡œ "pending", "error" ë˜ëŠ” "ok" ì¤‘ í•˜ë‚˜ì˜ stateë§Œ ê°€ì§ˆ ìˆ˜ ìˆìŒ

```ts
// ğŸ‘ good
interface RequestPending {
  state: "pending";
}

interface RequestError {
  state: "error";
  error: string;
}

interface RequestSuccess {
  state: "ok";
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}

// ğŸ˜Š í˜„ì¬ pageê°€ ì–´ë”˜ì§€ ëª…í™•í•¨
//    ë™ì‹œì— requestê°€ ì—¬ëŸ¬ê°œ ìƒê²¨ë„ ê²¹ì¹˜ì§€ ì•Šê³  í•˜ë‚˜ë§Œ ë³´ì—¬ì¤„ ìˆ˜ ìˆìŒ
function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `Loading ${currentPage}...`;
    case "error":
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case "ok":
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}
async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: "ok", pageText };
  } catch (e) {
    state.requests[newPage] = { state: "error", error: "" + e };
  }
}
```

- Airbus 330 ë¹„í–‰ê¸° ì‚¬ê³  ì‚¬ë¡€

```ts
ğŸ‘ stickë³„ë¡œ stateë¥¼ ë¶„ë¦¬í•˜ë©´ ìµœì¢… angleì„ ê²°ì •ì§“ëŠ” ë‹¤ë¥¸ ë¬´ì–¸ê°€ í•„ìš”í•˜ê³  ê±°ê¸°ì„œ angleì´ ì˜ëª» ê²°ì •ë  ìœ„í—˜ì´ ìˆìŒ 
interface CockpitControls {
  /** (pilot) Angle of the left side stick in degrees, 0 = neutral, + = forward */
  leftSideStick: number;
  /** (copilot) Angle of the right side stick in degrees, 0 = neutral, + = forward */
  rightSideStick: number;
}

ğŸ‘ ì• ì´ˆì— stickë³„ë¡œ stateë¥¼ ë¶„ë¦¬í•˜ì§€ ì•Šìœ¼ë©´ angleì´ ì˜ëª»ë  ìœ„í—˜ì´ ì—†ìŒ
interface CockpitControls {
  /** Angle of the stick in degrees, 0 = neutral, + = forward */
  stickAngle: number;
}
```

## Item 29: Be Liberal in What You Accept and Strict in What You Produce
>
> ğŸ“ robustness principle(Postel's law)
>
> : *be conservative in what you do, be liberal in what you accept from others.*
> when designing software or protocols, one should be strict in what one sends out, but liberal in what one accepts from others. The idea behind this principle is that it promotes interoperability between different systems by allowing them to handle errors and unexpected inputs gracefully.

### APIì˜ parameter typeì€ ë„“ê²Œ í•˜ì

- functionì˜ parameter type(`CameraOptions`)ì„ ë„“ê²Œ ì¡ìŒ
  - ëª¨ë“  propertyë“¤ì´ optional
  - ì¢Œí‘œ type(`LatLat`)ì´ 3ê°€ì§€
  - ë”°ë¼ì„œ `LngLatBounds`ì˜ typeì€ 19ê°œë‚˜ ë¨

```ts
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;

interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}

type LngLat =
  { lng: number; lat: number; } |
  { lon: number; lat: number; } |
  [number, number];

type LngLatBounds =
  {northeast: LngLat, southwest: LngLat} |
  [LngLat, LngLat] |
  [number, number, number, number];
```

### APIì˜ return typeì€ ì¢ê²Œ í•˜ì

- ë³´í†µ return valueë¡œ ë‹¤ì‹œ ë­”ê°€ í•˜ë‹ˆê¹Œ ë„“ì€ return typeì€ error ë‚˜ê¸° ì‰¬ì›€

```ts
// âŒ
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {center: {lat, lng}, zoom} = camera;
    // ~~~ Property 'lat' does not exist on type ...
    // ~~~ Property 'lng' does not exist on type ...
    zoom; // Type is number | undefined
    window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

### parameter typeê³¼ return typeê°„ ì¬ì‚¬ìš©í•˜ë ¤ë©´ return typeì„ canonical formìœ¼ë¡œ ì‚¬ìš©í•˜ê¸°(TypeLike ì‚¬ìš©í•˜ê¸°)

```ts
interface LngLat { lng: number; lat: number; };
type LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}

type LngLatBounds =
  {northeast: LngLatLike, southwest: LngLatLike} |
  [LngLatLike, LngLatLike] |
  [number, number, number, number];
  
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;

// âœ…
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {center: {lat, lng}, zoom} = camera; // OK
  zoom; // Type is number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

## Item 30: Donâ€™t Repeat Type Information in Documentation

## Item 31: Push Null Values to the Perimeter of Your Types

## Item 32: Prefer Unions of Interfaces to Interfaces of Unions

## Item 33: Prefer More Precise Alternatives to String Types

## Item 34: Prefer Incomplete Types to Inaccurate Types

## Item 35: Generate Types from APIs and Specs, Not Data

## Item 36: Name Types Using the Language of Your Problem Domain

## Item 37: Consider â€œBrandsâ€ for Nominal Typing
